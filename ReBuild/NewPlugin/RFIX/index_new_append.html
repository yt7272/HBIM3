description = document.getElementById('photo-description').value;
				
				if (typeof ACAPI.ComponentInfo_SaveComponentInfo === 'function') {
					ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
						.then(function (success) {
							if (success) {
								console.log('Component info saved successfully');
								hasUnsavedChanges = false;
								updateUnsavedIndicator();
								// Refresh component info display to confirm save
								refreshComponentInfoDisplay();
								// Force update of selected elements to ensure all data is fresh
								setTimeout(function() {
									UpdateSelectedElements();
								}, 100);
							} else {
								console.error('Failed to save component info');
							}
						})
						.catch(function (err) {
							console.error('Error saving component info:', err);
						});
				} else {
					console.warn('ComponentInfo_SaveComponentInfo API not available');
				}
			}
		}
		
		// Event listeners
		document.addEventListener('DOMContentLoaded', function() {
			// Debug: log ACAPI availability
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('HTML loaded: Checking ACAPI availability');
			} else {
				console.log('HTML loaded: Checking ACAPI availability');
			}
			function updateBridgeStatus(isAvailable, funcs, version) {
				const statusEl = document.getElementById('bridge-status');
				if (!statusEl) return;
				if (isAvailable) {
					statusEl.textContent = `(桥接就绪, ${funcs.length} 个函数)`;
					statusEl.style.color = '#10b981'; // success green
				} else {
					statusEl.textContent = '(桥接未连接)';
					statusEl.style.color = '#ef4444'; // error red
				}
				if (version) {
					statusEl.textContent += ` v${version}`;
				}
			}
			
			if (typeof ACAPI !== 'undefined') {
				// Try to log via ACAPI.LogDebug if available
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('HTML loaded: ACAPI object is defined');
				} else {
					console.log('ACAPI object is defined');
				}
				
				// List available functions
				const funcs = Object.keys(ACAPI).filter(key => typeof ACAPI[key] === 'function');
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('ACAPI functions: ' + JSON.stringify(funcs));
				} else {
					console.log('ACAPI functions:', funcs);
				}
				updateBridgeStatus(true, funcs, null);
				
				// Try to call GetPluginVersion to test bridge
				if (ACAPI.GetPluginVersion) {
					ACAPI.GetPluginVersion().then(version => {
						if (typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Plugin version from ACAPI: ' + version);
						} else {
							console.log('Plugin version from ACAPI:', version);
						}
						updateBridgeStatus(true, funcs, version);
					}).catch(err => {
						if (typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Failed to get plugin version: ' + err);
						} else {
							console.error('Failed to get plugin version:', err);
						}
						updateBridgeStatus(true, funcs, 'error');
					});
				}
			}
			// Initialize unsaved changes indicator
			updateUnsavedIndicator();
			
			// Initialize plugin version display
			updatePluginVersion();
			
			// Search input for IFC properties
			const searchInput = document.getElementById('property-search');
			searchInput.addEventListener('input', function(e) {
				filterProperties(e.target.value.toLowerCase());
			});

			// ComponentInfo input change tracking
			const componentIdInput = document.getElementById('component-id');
			const photoDescriptionInput = document.getElementById('photo-description');
			
			componentIdInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});
			
			photoDescriptionInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});

			// Refresh button
			document.getElementById('refresh-btn').addEventListener('click', function() {
				// In real implementation, re-fetch properties for current selection
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});

			// Retry button for error state
			document.getElementById('retry-btn').addEventListener('click', function() {
				document.getElementById('error-state').classList.add('hidden');
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// View IFC Properties button
			document.getElementById('view-ifc-properties-btn').addEventListener('click', function() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// Edit info button
			document.getElementById('edit-info-btn').addEventListener('click', function() {
				enterEditMode();
			});
			
			// Save info button
			document.getElementById('save-info-btn').addEventListener('click', function() {
				exitEditMode(true); // Save changes
			});
			
			// Cancel edit button
			document.getElementById('cancel-edit-btn').addEventListener('click', function() {
				exitEditMode(false); // Cancel without saving
			});
			
			// Select photos button
			document.getElementById('select-photos-btn').addEventListener('click', function() {
				// Debug logging
				const debugInfo = {
					currentElementGuid: currentElementGuid,
					isEditMode: isEditMode,
					ACAPI_Available: typeof ACAPI !== 'undefined',
					ComponentInfo_SelectPhotos_Available: typeof ACAPI.ComponentInfo_SelectPhotos === 'function'
				};
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('选择照片按钮被点击: ' + JSON.stringify(debugInfo));
				} else {
					console.log('选择照片按钮被点击', debugInfo);
				}
				
				if (!currentElementGuid) {
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('错误: No element selected (currentElementGuid is null)');
					} else {
						console.error('No element selected');
					}
					return;
				}
				
				if (typeof ACAPI.ComponentInfo_SelectPhotos === 'function') {
					ACAPI.ComponentInfo_SelectPhotos(currentElementGuid).then(function (selectedPaths) {
						if (selectedPaths && selectedPaths.length > 0) {
							// Append new photo paths to existing ones
							currentPhotoPaths = currentPhotoPaths.concat(selectedPaths);
							hasUnsavedChanges = true;
							updateUnsavedIndicator();
							// Save immediately with updated photo paths
							const componentId = document.getElementById('component-id').value;
							const photoDescription = document.getElementById('photo-description').value;
							
							ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
								.then(function (success) {
									if (success) {
										console.log('Photos added and saved successfully');
										hasUnsavedChanges = false;
										updateUnsavedIndicator();
										// Enable view photos button and update preview
										document.getElementById('view-photos-btn').disabled = false;
										updatePhotoPreview();
									} else {
										console.error('Failed to save photos');
									}
								})
								.catch(function (err) {
									console.error('Error saving photos:', err);
								});
						}
					}).catch(function (err) {
						console.error('Error selecting photos:', err);
					});
				} else {
					console.warn('ComponentInfo_SelectPhotos API not available');
				}
			});
			
			// View photos button - open current photo file
			document.getElementById('view-photos-btn').addEventListener('click', function() {
				if (!currentElementGuid) {
					console.error('No element selected');
					return;
				}
				
				if (!currentPhotoPaths || currentPhotoPaths.length === 0) {
					console.error('No photos available');
					return;
				}
				
				// Open the currently displayed photo file
				const currentPhotoPath = currentPhotoPaths[currentPhotoIndex];
				if (typeof ACAPI.ComponentInfo_ViewPhotos === 'function') {
					ACAPI.ComponentInfo_ViewPhotos([currentElementGuid, currentPhotoPath])
						.then(function (success) {
							if (!success) {
								console.error('Failed to open photo file');
							}
						})
						.catch(function (err) {
							console.error('Error opening photo file:', err);
						});
				} else {
					console.warn('ComponentInfo_ViewPhotos API not available');
				}
			});
			
			// Photo navigation buttons
			document.getElementById('prev-photo-btn').addEventListener('click', function() {
				showPrevPhoto();
			});
			
			document.getElementById('next-photo-btn').addEventListener('click', function() {
				showNextPhoto();
			});

			// Initial load - no element selected
			// Show empty state initially
			document.getElementById('empty-state').classList.remove('hidden');
			// Clear any previous properties
			currentProperties = [];
			const groups = groupProperties(currentProperties);
			renderPropertyGroups(groups);
			
			// Initial call to UpdateSelectedElements to get current selection
			UpdateSelectedElements();
			
			// Set up periodic selection update (every 250ms for faster response)
			setInterval(function() {
				UpdateSelectedElements();
			}, 250);
		});

		// Keep existing ACAPI bridge functions
		function UpdateSelectedElements() {
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					loadIFCProperties(elemInfos);
					
					// Update ComponentInfo fields
					if (elemInfos && elemInfos.length > 0) {
						const elem = elemInfos[0];
						const newElementGuid = elem[0]; // Get new GUID
						
						// Check if element has changed
						const elementChanged = (newElementGuid !== currentElementGuid);
						
						// If element changed and we're in edit mode, exit edit mode
						if (elementChanged && isEditMode) {
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('元素变化检测: 从 ' + currentElementGuid + ' 切换到 ' + newElementGuid + ', 退出编辑模式');
							} else {
								console.log('元素变化检测: 从', currentElementGuid, '切换到', newElementGuid, ', 退出编辑模式');
							}
							// Exit edit mode without saving
							exitEditMode(false); // false = don't save
						}
						
						// Update current element GUID
						previousElementGuid = currentElementGuid;
						currentElementGuid = newElementGuid;
						
						// Debug logging
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('UpdateSelectedElements: 设置 currentElementGuid = ' + currentElementGuid + ', elemInfos长度: ' + elemInfos.length + ', 元素变化: ' + elementChanged);
						} else {
							console.log('UpdateSelectedElements: 设置 currentElementGuid =', currentElementGuid, 'elemInfos长度:', elemInfos.length, '元素变化:', elementChanged);
						}
						
						// Load component info if API is available
						// Only load component info if NOT in edit mode (to prevent overwriting user input)
						if (!isEditMode && typeof ACAPI.ComponentInfo_GetComponentInfo === 'function') {
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: 非编辑模式，加载构件信息');
							} else {
								console.log('UpdateSelectedElements: 非编辑模式，加载构件信息');
							}
							
							ACAPI.ComponentInfo_GetComponentInfo(currentElementGuid).then(function (componentInfo) {
								if (componentInfo && componentInfo.componentId !== undefined) {
									document.getElementById('component-id').value = componentInfo.componentId || '';
									document.getElementById('photo-description').value = componentInfo.photoDescription || '';
									currentPhotoPaths = componentInfo.photoPaths || [];
									// Update photo paths display if needed
									if (currentPhotoPaths.length > 0) {
										document.getElementById('view-photos-btn').disabled = false;
										updatePhotoPreview();
									} else {
										document.getElementById('view-photos-btn').disabled = true;
									}
									
									// Debug logging
									if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
										ACAPI.LogDebug('UpdateSelectedElements: 加载构件信息成功，构件编号="' + componentInfo.componentId + '"');
									}
								} else {
									// No component info stored yet - keep existing values if any
									// Don't clear fields, just log
									if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
										ACAPI.LogDebug('UpdateSelectedElements: 构件无保存信息，保持当前值');
									} else {
										console.log('UpdateSelectedElements: 构件无保存信息，保持当前值');
									}
									// Only initialize empty fields if they're currently empty
									const componentIdInput = document.getElementById('component-id');
									const photoDescInput = document.getElementById('photo-description');
									if (!componentIdInput.value) componentIdInput.value = '';
									if (!photoDescInput.value) photoDescInput.value = '';
									currentPhotoPaths = [];
									document.getElementById('view-photos-btn').disabled = true;
									updatePhotoPreview();
								}
							}).catch(function (err) {
								console.error('Failed to load component info:', err);
								// Don't clear fields on error
								if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
									ACAPI.LogDebug('UpdateSelectedElements: 加载构件信息失败，保持当前值，错误: ' + err);
								}
							});
						} else if (isEditMode) {
							// In edit mode - don't load component info to prevent overwriting user input
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: 编辑模式中，跳过构件信息加载');
							} else {
								console.log('UpdateSelectedElements: 编辑模式中，跳过构件信息加载');
							}
						} else {
							// ComponentInfo_GetComponentInfo API not available
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: ComponentInfo_GetComponentInfo API 不可用');
							}
						}
					} else {
						// No element selected
						currentElementGuid = null;
						
						// Debug logging
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('UpdateSelectedElements: 没有选择元素，设置 currentElementGuid = null');
						} else {
							console.log('UpdateSelectedElements: 没有选择元素，设置 currentElementGuid = null');
						}
						
						document.getElementById('component-id').value = '';
						document.getElementById('photo-description').value = '';
						document.getElementById('view-photos-btn').disabled = true;
					}
				});
			}
		}

		function UpdateIFCProperties() {
			// Refresh properties for currently selected element(s)
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					loadIFCProperties(elemInfos);
				});
			}
		}
	</script>
</body>
</html>
