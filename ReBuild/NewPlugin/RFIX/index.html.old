<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>HBIMÊûÑ‰ª∂‰ø°ÊÅØËæìÂÖ•Â∑•ÂÖ∑</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style type="text/css">
		/* CSS Variables for Industrial Dark Theme */
		:root {
			--bg-dark: #1a1d23;
			--bg-card: #252a33;
			--text-primary: #e2e8f0;
			--text-secondary: #94a3b8;
			--accent: #06b6d4;
			--accent-hover: #22d3ee;
			--border: #3f4a5c;
			--hover: #2d3748;
			--shadow: rgba(0, 0, 0, 0.3);
			--success: #10b981;
			--warning: #f59e0b;
			--error: #ef4444;
			--radius: 4px;
			--transition: all 0.2s ease;
		}

		/* Base Reset */
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
			background-color: var(--bg-dark);
			color: var(--text-primary);
			font-size: 13px;
			line-height: 1.4;
			padding: 12px;
			min-width: 450px;
			min-height: 150px;
			overflow-x: auto;
			user-select: none;
		}

		/* Typography */
		h1, h2, h3 {
			font-weight: 600;
			line-height: 1.2;
		}

		h2 {
			font-size: 14px;
			color: var(--accent);
			margin-bottom: 8px;
			display: flex;
			align-items: center;
			gap: 6px;
		}

		h2::before {
			content: '';
			display: inline-block;
			width: 12px;
			height: 12px;
			background-color: var(--accent);
			border-radius: 2px;
		}

		.plugin-title {
			font-size: 18px;
			font-weight: 600;
			color: #06b6d4; /* var(--accent) */
			margin-bottom: 12px;
			padding-bottom: 8px;
			border-bottom: 2px solid #3f4a5c; /* var(--border) */
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.plugin-title::before {
			content: 'üìã';
			font-size: 16px;
		}

		/* Header Section */
		.header {
			background: #252a33; /* var(--bg-card) */
			border-radius: 4px; /* var(--radius) */
			padding: 12px;
			margin-bottom: 12px;
			border: 1px solid #3f4a5c; /* var(--border) */
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* var(--shadow) */
		}

		.element-summary {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 10px;
			margin-bottom: 12px;
		}

		.summary-item {
			display: flex;
			flex-direction: column;
		}

		.summary-label {
			font-size: 11px;
			color: var(--text-secondary);
			text-transform: uppercase;
			letter-spacing: 0.05em;
			margin-bottom: 2px;
		}

		.summary-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			font-size: 12px;
			background: rgba(0, 0, 0, 0.2);
			padding: 4px 8px;
			border-radius: var(--radius);
			border-left: 3px solid var(--accent);
			word-break: break-all;
		}

		/* Tab Navigation */
		.tab-navigation {
			display: flex;
			gap: 2px;
			margin-bottom: 12px;
			border-bottom: 2px solid var(--border);
		}

		.tab-button {
			background: transparent;
			border: none;
			padding: 8px 16px;
			color: var(--text-secondary);
			font-size: 13px;
			font-weight: 500;
			cursor: pointer;
			transition: var(--transition);
			position: relative;
			border-radius: var(--radius) var(--radius) 0 0;
		}

		.tab-button:hover {
			color: var(--text-primary);
			background: rgba(63, 74, 92, 0.2);
		}

		.tab-button.active {
			color: var(--accent);
			background: var(--bg-card);
			border-bottom: 2px solid var(--accent);
		}

		.tab-button.active::after {
			content: '';
			position: absolute;
			bottom: -2px;
			left: 0;
			right: 0;
			height: 2px;
			background: var(--accent);
		}

		/* Tab Content */
		.tab-content {
			display: none;
		}

		.tab-content.active {
			display: block;
		}

		/* ComponentInfo Form */
		.form-group {
			margin-bottom: 12px;
		}

		.form-label {
			display: block;
			font-size: 12px;
			color: var(--text-secondary);
			margin-bottom: 4px;
			font-weight: 500;
		}

		.form-input {
			width: 100%;
			padding: 8px 12px;
			background: var(--bg-dark);
			border: 1px solid var(--border);
			border-radius: var(--radius);
			color: var(--text-primary);
			font-size: 13px;
			transition: var(--transition);
		}

		.form-input:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
		}

		.form-input:disabled {
			background: rgba(26, 29, 35, 0.5);
			color: var(--text-secondary);
			cursor: not-allowed;
		}

		.photo-preview {
			width: 100%;
			height: 200px;
			background: rgba(0, 0, 0, 0.2);
			border: 1px dashed var(--border);
			border-radius: var(--radius);
			display: flex;
			align-items: center;
			justify-content: center;
			margin-bottom: 12px;
			overflow: hidden;
		}

		.photo-preview img {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
		}

		.photo-preview-placeholder {
			color: var(--text-secondary);
			font-size: 12px;
			text-align: center;
		}

		.photo-preview-container {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.photo-navigation {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 12px;
		}

		.photo-nav-btn {
			background: var(--bg-card);
			border: 1px solid var(--border);
			color: var(--text-primary);
			width: 28px;
			height: 28px;
			border-radius: var(--radius);
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 14px;
			transition: var(--transition);
		}

		.photo-nav-btn:hover:not(:disabled) {
			background: var(--hover);
			border-color: var(--accent);
		}

		.photo-nav-btn:disabled {
			opacity: 0.4;
			cursor: not-allowed;
		}

		.photo-index {
			font-size: 12px;
			color: var(--text-secondary);
			min-width: 60px;
			text-align: center;
		}
		
		.photo-debug-info {
			font-size: 10px;
			color: #ff6b6b;
			background: rgba(255, 107, 107, 0.1);
			border: 1px solid rgba(255, 107, 107, 0.3);
			border-radius: var(--radius);
			padding: 6px 8px;
			margin-top: 4px;
			display: none;
			flex-direction: column;
			gap: 2px;
		}
		
		.photo-debug-info.hidden {
			display: none;
		}
		
		.photo-debug-info:not(.hidden) {
			display: flex;
		}
		
		.debug-header {
			font-weight: bold;
			color: #ff6b6b;
			font-size: 10px;
		}
		
		.debug-content {
			font-size: 9px;
			color: #ffa8a8;
			white-space: pre-wrap;
			word-break: break-all;
			max-height: 60px;
			overflow-y: auto;
		}

		/* Controls Bar */
		.controls {
			display: flex;
			gap: 8px;
			margin-top: 12px;
		}

		.search-box {
			flex: 1;
			position: relative;
		}

		.search-box input {
			width: 100%;
			padding: 6px 10px 6px 32px;
			background: var(--bg-dark);
			border: 1px solid var(--border);
			border-radius: var(--radius);
			color: var(--text-primary);
			font-size: 12px;
			transition: var(--transition);
		}

		.search-box input:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
		}

		.search-box::before {
			content: 'üîç';
			position: absolute;
			left: 10px;
			top: 50%;
			transform: translateY(-50%);
			font-size: 12px;
			color: var(--text-secondary);
			pointer-events: none;
		}

		button {
			background: var(--accent);
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: var(--radius);
			font-size: 12px;
			font-weight: 500;
			cursor: pointer;
			transition: var(--transition);
			display: inline-flex;
			align-items: center;
			gap: 4px;
			white-space: nowrap;
		}

		button:hover {
			background: var(--accent-hover);
			transform: translateY(-1px);
			box-shadow: 0 2px 4px var(--shadow);
		}

		button:active {
			transform: translateY(0);
		}

		button.secondary {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-secondary);
		}

		button.secondary:hover {
			background: var(--hover);
			color: var(--text-primary);
		}

		button:disabled {
			background: rgba(6, 182, 212, 0.3);
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		button.secondary:disabled {
			background: transparent;
			border-color: rgba(63, 74, 92, 0.5);
			color: rgba(148, 163, 184, 0.5);
		}

		/* Property Groups */
		.property-groups {
			margin-top: 16px;
			overflow-x: auto;
			max-width: 100%;
		}

		.group {
			background: var(--bg-card);
			border-radius: var(--radius);
			border: 1px solid var(--border);
			margin-bottom: 10px;
			overflow: hidden;
		}

		.group-header {
			padding: 10px 12px;
			background: rgba(63, 74, 92, 0.3);
			display: flex;
			justify-content: space-between;
			align-items: center;
			cursor: pointer;
			transition: var(--transition);
		}

		.group-header:hover {
			background: rgba(63, 74, 92, 0.5);
		}

		.group-header h3 {
			font-size: 13px;
			font-weight: 600;
			color: var(--text-primary);
		}

		.group-badge {
			background: var(--accent);
			color: white;
			font-size: 10px;
			padding: 2px 6px;
			border-radius: 10px;
			font-weight: 600;
		}

		.group-content {
			padding: 0;
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease;
		}

		.group.expanded .group-content {
			max-height: 2000px;
		}

		/* Property Table */
		.property-table {
			width: 100%;
			border-collapse: collapse;
			font-size: 12px;
		}

		.property-table thead {
			background: rgba(0, 0, 0, 0.2);
			border-bottom: 2px solid var(--border);
		}

		.property-table th {
			padding: 8px 10px;
			text-align: left;
			font-weight: 600;
			color: var(--text-secondary);
			text-transform: uppercase;
			font-size: 11px;
			letter-spacing: 0.05em;
		}

		.property-table tbody tr {
			border-bottom: 1px solid rgba(63, 74, 92, 0.3);
			transition: var(--transition);
		}

		.property-table tbody tr:hover {
			background: var(--hover);
		}

		.property-table td {
			padding: 8px 10px;
			vertical-align: top;
		}

		.property-name {
			font-weight: 500;
			color: var(--text-primary);
			min-width: 140px;
		}

		.property-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			color: var(--accent);
			word-break: break-word;
			max-width: 200px;
		}

		.property-type {
			color: var(--text-secondary);
			font-style: italic;
			font-size: 11px;
		}

		.property-unit {
			color: var(--success);
			font-size: 11px;
		}

		/* Empty & Loading States */
		.empty-state, .loading-state {
			text-align: center;
			padding: 30px 20px;
			color: var(--text-secondary);
		}

		.empty-state h3, .loading-state h3 {
			color: var(--text-secondary);
			margin-bottom: 8px;
		}

		/* Warning Notification */
		.warning-notice {
			background: rgba(245, 158, 11, 0.1);
			border: 1px solid var(--warning);
			border-radius: var(--radius);
			padding: 8px 12px;
			margin: 10px 0;
			color: var(--warning);
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.warning-notice::before {
			content: '‚ö†Ô∏è';
			font-size: 14px;
		}

		/* Error Notification */
		.error-notice {
			background: rgba(239, 68, 68, 0.1);
			border: 1px solid var(--error);
			border-radius: var(--radius);
			padding: 8px 12px;
			margin: 10px 0;
			color: var(--error);
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.error-notice::before {
			content: '‚ùå';
			font-size: 14px;
		}

		/* Responsive */
		@media (max-width: 500px) {
			.element-summary {
				grid-template-columns: 1fr;
			}
			.controls {
				flex-wrap: wrap;
			}
			.property-table {
				display: block;
				overflow-x: auto;
			}
		}

		/* Utility */
		.hidden {
			display: none !important;
		}

		.fade-in {
			animation: fadeIn 0.3s ease;
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		.unsaved-indicator {
			color: var(--warning);
			font-weight: bold;
			margin-left: 2px;
		}
	</style>
</head>

<body class="palette">
	<div class="header">
		<div class="plugin-title">ÊûÑ‰ª∂‰ø°ÊÅØ‰∏éIFCÂ±ûÊÄß <span id="bridge-status" style="font-size: 10px; color: #ef4444; margin-left: 8px;">(Ê°•Êé•Ê£ÄÊµã‰∏≠...)</span></div>
		<div class="element-summary">
			<div class="summary-item">
				<div class="summary-label">GUID</div>
				<div id="summary-guid" class="summary-value">{GUID}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Type</div>
				<div id="summary-type" class="summary-value">{Element Type}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Element ID</div>
				<div id="summary-id" class="summary-value">{Element ID}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Plugin Version</div>
				<div id="summary-version" class="summary-value">0.0.0.0</div>
			</div>
		</div>
		<div id="multi-selection-warning" class="warning-notice hidden">
			‚ö†Ô∏è Multiple elements selected. Showing properties for the first element only.
		</div>
	</div>

	<!-- Tab Navigation -->
	<div class="tab-navigation">
		<button id="componentinfo-tab" class="tab-button active">ComponentInfo<span id="componentinfo-unsaved-indicator" class="unsaved-indicator hidden"> *</span></button>
		<button id="ifc-properties-tab" class="tab-button">IFC Properties</button>
	</div>

	<!-- ComponentInfo Tab Content -->
	<div id="componentinfo-content" class="tab-content active">
		<div class="form-group">
			<label class="form-label" for="component-id">ÊûÑ‰ª∂ÁºñÂè∑</label>
			<input type="text" id="component-id" class="form-input" placeholder="Enter component ID" disabled>
		</div>
		
		<div class="form-group">
			<label class="form-label" for="photo-description">ÁÖßÁâáÊèèËø∞</label>
			<input type="text" id="photo-description" class="form-input" placeholder="Enter photo description" disabled>
		</div>
		
		<div class="form-group">
			<label class="form-label">ÁÖßÁâáÈ¢ÑËßà</label>
			<div class="photo-preview-container">
				<div class="photo-preview">
					<div class="photo-preview-placeholder">Êú™ÈÄâÊã©ÁÖßÁâá</div>
					<img id="photo-display" src="" alt="Photo preview" class="hidden">
				</div>
				<div class="photo-navigation hidden">
					<button id="prev-photo-btn" class="photo-nav-btn" disabled>‚Äπ</button>
					<span id="photo-index" class="photo-index">0 / 0</span>
					<button id="next-photo-btn" class="photo-nav-btn" disabled>‚Ä∫</button>
				</div>
				<!-- Ë∞ÉËØï‰ø°ÊÅØÊòæÁ§∫Âå∫Âüü -->
				<div id="photo-debug-info" class="photo-debug-info hidden">
					<div class="debug-header">Ë∞ÉËØï‰ø°ÊÅØ (F12ÊéßÂà∂Âè∞‰∏çÂèØÁî®Êó∂‰ΩøÁî®):</div>
					<div class="debug-content"></div>
				</div>
			</div>
		</div>
		
		<div class="controls">
			<button id="select-photos-btn" class="secondary" disabled>ÈÄâÊã©ÁÖßÁâá</button>
			<button id="view-photos-btn" class="secondary" disabled>Êü•ÁúãÁÖßÁâá</button>
			<button id="edit-info-btn">ÁºñËæë‰ø°ÊÅØ</button>
			<button id="save-info-btn" class="hidden">‰øùÂ≠ò</button>
			<button id="cancel-edit-btn" class="secondary hidden">ÂèñÊ∂àÁºñËæë</button>
		</div>
		
	</div>

	<!-- IFC Properties Tab Content -->
	<div id="ifc-properties-content" class="tab-content">
		<div class="controls">
			<div class="search-box">
				<input type="text" id="property-search" placeholder="Search properties..." />
			</div>
			<button id="refresh-btn" title="Refresh properties">
				‚Üª Refresh
			</button>
			<button id="view-ifc-properties-btn">Êü•ÁúãÊûÑ‰ª∂ÁöÑIFCÂ±ûÊÄß</button>
		</div>

		<div id="loading-state" class="loading-state hidden">
			<h3>Loading IFC properties...</h3>
			<p>Please wait while fetching property data.</p>
		</div>

		<div id="empty-state" class="empty-state hidden">
			<h3>No element selected</h3>
			<p>Select an element in Archicad to view its IFC properties.</p>
		</div>
		
		<div id="no-match-state" class="empty-state hidden">
			<h3>No matching properties</h3>
			<p>Try adjusting your search to find what you're looking for.</p>
		</div>
		
		<div id="error-state" class="error-notice hidden">
			<h3>Error loading IFC properties</h3>
			<p id="error-message">An unexpected error occurred while fetching IFC properties.</p>
			<button id="retry-btn" class="secondary" style="margin-top: 8px;">Retry</button>
		</div>

		<div id="property-groups" class="property-groups">
			<!-- Property groups will be inserted here by JavaScript -->
		</div>
	</div>

	<script type="text/javascript">
		// Mock data for demonstration
		const mockPropertyData = {
			guid: "{335B0B7A-1234-5678-ABCD-EF0123456789}",
			type: "IfcWall",
			elementId: "1001",
			properties: [
				{
					schema: "IFC4",
					category: "General",
					name: "Name",
					value: "Interior Wall 001",
					type: "IfcLabel",
					unit: null
				},
				{
					schema: "IFC4",
					category: "General",
					name: "Description",
					value: "Load bearing wall with fire rating",
					type: "IfcText",
					unit: null
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Length",
					value: "5000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Height",
					value: "3000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Material",
					value: "Concrete",
					type: "IfcMaterial",
					unit: null
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Thickness",
					value: "200.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Performance",
					name: "Fire Rating",
					value: "120",
					type: "IfcTimeMeasure",
					unit: "minutes"
				}
			]
		};

		let currentProperties = []; // Holds properties for currently selected element, initially empty
		let debugInfo = {}; // Store debug information for display
		let isEditMode = false;
		let currentElementGuid = null; // GUID of currently selected element for ComponentInfo operations
		let previousElementGuid = null; // Track previous element GUID to detect changes
		let currentPhotoPaths = []; // Photo paths for currently selected element
		let hasUnsavedChanges = false; // Track unsaved changes in ComponentInfo
		
		function updateUnsavedIndicator() {
			const indicator = document.getElementById('componentinfo-unsaved-indicator');
			if (indicator) {
				if (hasUnsavedChanges) {
					indicator.classList.remove('hidden');
				} else {
					indicator.classList.add('hidden');
				}
			}
		}
		
		// Tab switching functionality
		function switchTab(tabId) {
			// Hide all tab contents
			document.querySelectorAll('.tab-content').forEach(content => {
				content.classList.remove('active');
			});
			
			// Deactivate all tab buttons
			document.querySelectorAll('.tab-button').forEach(button => {
				button.classList.remove('active');
			});
			
			// Activate selected tab
			document.getElementById(tabId + '-content').classList.add('active');
			document.getElementById(tabId + '-tab').classList.add('active');
		}
		
		// Event listeners for tab buttons
		document.getElementById('componentinfo-tab').addEventListener('click', () => {
			switchTab('componentinfo');
		});
		
		document.getElementById('ifc-properties-tab').addEventListener('click', () => {
			switchTab('ifc-properties');
		});
		
		// Transform C++ property array format to UI property object format
		// C++ format: [propertySetName, propertyName, propertyValue, propertyType, unit, isValid]
		// UI format: {schema, category, name, value, type, unit}
		function transformCppPropertiesToUI(cppProperties) {
			console.log('transformCppPropertiesToUI called with:', cppProperties);
			if (!cppProperties) {
				console.warn('cppProperties is null or undefined');
				return [];
			}
			if (!Array.isArray(cppProperties)) {
				console.warn('cppProperties is not an array:', typeof cppProperties, cppProperties);
				return [];
			}
			console.log(`Received ${cppProperties.length} properties from C++ backend`);
			const uiProperties = [];
			for (let i = 0; i < cppProperties.length; i++) {
				const prop = cppProperties[i];
				if (!Array.isArray(prop) || prop.length < 6) {
					console.warn(`Property at index ${i} is invalid:`, prop);
					continue;
				}
				const [propertySetName, propertyName, propertyValue, propertyType, unit, isValid] = prop;
				// Filter out invalid properties
				if (isValid === false) {
					console.log(`Property ${propertySetName}.${propertyName} is invalid (isValid=false), skipping`);
					continue;
				}
				// Map propertySetName -> category
				// For schema, we can try to extract IFC version from propertySetName, default to "IFC"
				let schema = "IFC";
				const schemaMatch = propertySetName.match(/IFC(2X3|4|2x3)?/i);
				if (schemaMatch) schema = schemaMatch[0].toUpperCase();
				uiProperties.push({
					schema: schema,
					category: propertySetName,
					name: propertyName,
					value: propertyValue,
					type: propertyType,
					unit: unit || null
				});
				// Log DEBUG_INFO properties
				if (propertySetName === 'DEBUG_INFO') {
					console.log(`DEBUG_INFO: ${propertyName} = ${propertyValue}`);
				}
			}
			console.log(`Transformed to ${uiProperties.length} UI properties`);
			return uiProperties;
		}
		
		// Group properties by category (propertySetName)
		function groupProperties(properties) {
			const groups = {};
			properties.forEach(prop => {
				const key = prop.category; // propertySetName
				if (!groups[key]) {
					groups[key] = {
						schema: prop.schema,
						category: prop.category,
						properties: []
					};
				}
				groups[key].properties.push(prop);
			});
			return Object.values(groups);
		}

		// Render property groups
		function renderPropertyGroups(groups) {
			const container = document.getElementById('property-groups');
			container.innerHTML = '';

			if (groups.length === 0) {
				// Check if we have an element selected (empty-state hidden)
				const emptyState = document.getElementById('empty-state');
				if (emptyState.classList.contains('hidden')) {
					// Element is selected but no properties match filter
					document.getElementById('no-match-state').classList.remove('hidden');
				} else {
					// No element selected
					emptyState.classList.remove('hidden');
				}
				return;
			} else {
				// Hide both empty and no-match states
				document.getElementById('empty-state').classList.add('hidden');
				document.getElementById('no-match-state').classList.add('hidden');
			}

			// Lazy rendering: render groups in batches for better performance
			const batchSize = 3; // Render 3 groups per frame
			let currentIndex = 0;
			
			function renderNextBatch() {
				const batch = groups.slice(currentIndex, currentIndex + batchSize);
				currentIndex += batchSize;
				
				batch.forEach(group => {
					const groupElement = document.createElement('div');
					groupElement.className = 'group expanded';
					groupElement.innerHTML = `
						<div class="group-header" onclick="toggleGroup(this.parentElement)">
							<h3>${group.category}</h3>
							<span class="group-badge">${group.properties.length}</span>
						</div>
						<div class="group-content">
							<table class="property-table">
								<thead>
									<tr>
										<th>Property Name</th>
										<th>Value</th>
										<th>Type</th>
										<th>Unit</th>
									</tr>
								</thead>
								<tbody>
									${group.properties.map(prop => `
										<tr>
											<td class="property-name">${prop.name}</td>
											<td class="property-value">${prop.value}</td>
											<td class="property-type">${prop.type}</td>
											<td class="property-unit">${prop.unit || '‚Äî'}</td>
										</tr>
									`).join('')}
								</tbody>
							</table>
						</div>
					`;
					container.appendChild(groupElement);
				});
				
				// If there are more groups to render, schedule next batch
				if (currentIndex < groups.length) {
					requestAnimationFrame(renderNextBatch);
				}
			}
			
			// Start rendering
			requestAnimationFrame(renderNextBatch);
		}

		// Toggle group expansion
		function toggleGroup(groupElement) {
			groupElement.classList.toggle('expanded');
		}

		// Filter properties based on search input
		function filterProperties(searchTerm) {
			const filtered = currentProperties.filter(prop => 
				prop.name.toLowerCase().includes(searchTerm) ||
				prop.value.toLowerCase().includes(searchTerm) ||
				prop.type.toLowerCase().includes(searchTerm) ||
				prop.category.toLowerCase().includes(searchTerm)
			);
			const groups = groupProperties(filtered);
			renderPropertyGroups(groups);
		}

		// Update summary from selected element
		function updateElementSummary(guid, type, elementId) {
			document.getElementById('summary-guid').textContent = guid;
			document.getElementById('summary-type').textContent = type;
			document.getElementById('summary-id').textContent = elementId;
		}

		// Show loading state
		function showLoading() {
			document.getElementById('loading-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('error-state').classList.add('hidden');
		}

		// Hide loading state
		function hideLoading() {
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('property-groups').classList.remove('hidden');
		}

		// Show error state
		function showError(errorMessage) {
			document.getElementById('error-message').textContent = errorMessage || 'An unexpected error occurred while fetching IFC properties.';
			document.getElementById('error-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('no-match-state').classList.add('hidden');
		}

		// Main function to load and display properties
		function loadIFCProperties(elementInfos) {
			console.log('loadIFCProperties called with elementInfos:', elementInfos);
			showLoading();

			// Simulate API delay (keep for fallback)
			setTimeout(() => {
				if (!elementInfos || elementInfos.length === 0) {
					document.getElementById('empty-state').classList.remove('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					document.getElementById('property-groups').classList.add('hidden');
					updateElementSummary('‚Äî', '‚Äî', '‚Äî');
					currentProperties = [];
					// Hide multi-selection warning
					document.getElementById('multi-selection-warning').classList.add('hidden');
					hideLoading();
					return;
				}
				
				// Show/hide multi-selection warning
				const warning = document.getElementById('multi-selection-warning');
				if (elementInfos.length > 1) {
					warning.classList.remove('hidden');
				} else {
					warning.classList.add('hidden');
				}
				
				// Use first selected element
				const elem = elementInfos[0];
				const elementGuid = elem[0];
				updateElementSummary(elem[0], elem[1], elem[2]);
				
				// Try to fetch real IFC properties from C++ backend
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetAllIFCProperties === 'function') {
					console.log('ACAPI.GetAllIFCProperties available, calling with elementGuid:', elementGuid);
					ACAPI.GetAllIFCProperties(elementGuid)
						.then(cppProperties => {
							console.log('ACAPI.GetAllIFCProperties returned:', cppProperties);
							// Transform C++ property format to UI format
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							console.log('After transformation:', uiProperties.length, 'UI properties');
							if (uiProperties.length === 0) {
								// If no properties returned, fall back to mock data for testing
								console.warn('No IFC properties returned from backend, using mock data for demonstration');
								console.warn('Raw C++ properties that were received:', cppProperties);
								currentProperties = mockPropertyData.properties;
							} else {
								console.log('Using real IFC properties from backend');
								currentProperties = uiProperties;
							}
							
							const groups = groupProperties(currentProperties);
							console.log('Grouped into', groups.length, 'groups');
							renderPropertyGroups(groups);
							document.getElementById('empty-state').classList.add('hidden');
							document.getElementById('no-match-state').classList.add('hidden');
							hideLoading();
						})
						.catch(error => {
							console.error('Failed to fetch IFC properties:', error);
							// Show error to user
							showError(`Failed to fetch IFC properties: ${error.message || error}`);
							hideLoading();
						});
				} else {
					// ACAPI not available, use mock data (for testing outside Archicad)
					console.warn('ACAPI not available, using mock data for demonstration');
					currentProperties = mockPropertyData.properties;
					
					const groups = groupProperties(currentProperties);
					renderPropertyGroups(groups);
					document.getElementById('empty-state').classList.add('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					hideLoading();
				}
			}, 300);
		}
		
		// Update plugin version display
		function updatePluginVersion() {
			const versionElement = document.getElementById('summary-version');
			if (!versionElement) return;
			
			// Clear cache, avoid old version info residue
			if (typeof ACAPI !== 'undefined' && ACAPI.ClearIFCPropertyCache) {
				ACAPI.ClearIFCPropertyCache();
			}
			
			// Get plugin version
			if (typeof ACAPI !== 'undefined' && ACAPI.GetPluginVersion) {
				ACAPI.GetPluginVersion().then(version => {
					console.log('Plugin version from C++:', version);
					versionElement.textContent = version;
				}).catch(error => {
					console.warn('Failed to get plugin version:', error);
					versionElement.textContent = 'unknown';
				});
			} else {
				// ACAPI not available, use default
				versionElement.textContent = '0.0.0.0';
			}
		}
		
		// ComponentInfo edit mode functions
 		function enterEditMode() {
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('ËøõÂÖ•ÁºñËæëÊ®°ÂºèÔºåcurrentElementGuid: ' + currentElementGuid);
			} else {
				console.log('ËøõÂÖ•ÁºñËæëÊ®°ÂºèÔºåcurrentElementGuid:', currentElementGuid);
			}
			isEditMode = true;
			hasUnsavedChanges = false;
			updateUnsavedIndicator();
			document.getElementById('component-id').disabled = false;
			document.getElementById('photo-description').disabled = false;
			document.getElementById('select-photos-btn').disabled = false;
			// Hide edit button, show save and cancel buttons
			document.getElementById('edit-info-btn').classList.add('hidden');
			document.getElementById('save-info-btn').classList.remove('hidden');
			document.getElementById('cancel-edit-btn').classList.remove('hidden');
			document.getElementById('view-ifc-properties-btn').disabled = true;
			// Notify C++ backend about edit mode change
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_SetEditMode === 'function') {
				ACAPI.ComponentInfo_SetEditMode('true').catch(err => console.warn('Failed to set edit mode:', err));
 			}
 		}
		
		// Photo preview functionality
		let currentPhotoIndex = 0;
		
		function showPhotoAtIndex(index) {
			const photoDisplay = document.getElementById('photo-display');
			const photoPlaceholder = document.querySelector('.photo-preview-placeholder');
			const prevBtn = document.getElementById('prev-photo-btn');
			const nextBtn = document.getElementById('next-photo-btn');
			const photoIndex = document.getElementById('photo-index');
			const photoNav = document.querySelector('.photo-navigation');
			
			if (!currentPhotoPaths || currentPhotoPaths.length === 0) {
				// No photos - show placeholder
				photoDisplay.classList.add('hidden');
				photoPlaceholder.classList.remove('hidden');
				photoPlaceholder.textContent = 'Êú™ÈÄâÊã©ÁÖßÁâá';
				photoNav.classList.add('hidden');
				return;
			}
			
			// Validate index
			if (index < 0) index = 0;
			if (index >= currentPhotoPaths.length) index = currentPhotoPaths.length - 1;
			currentPhotoIndex = index;
			
			// Update navigation buttons
			prevBtn.disabled = (currentPhotoIndex === 0);
			nextBtn.disabled = (currentPhotoIndex === currentPhotoPaths.length - 1);
			
			// Update index display
			photoIndex.textContent = `${currentPhotoIndex + 1} / ${currentPhotoPaths.length}`;
			
			// Show photo - convert relative path to full path
			const photoPath = currentPhotoPaths[currentPhotoIndex];
			
			// ÂõæÁâáÂä†ËΩΩËæÖÂä©ÂáΩÊï∞ - Ê∑ªÂä†ËØ¶ÁªÜÁöÑÈîôËØØÂ§ÑÁêÜ
			function loadPhotoWithErrorHandling(imgElement, pathToLoad, description) {
				// Ê∏ÖÈô§‰πãÂâçÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
				imgElement.onerror = null;
				imgElement.onload = null;
				
				// Ëé∑ÂèñË∞ÉËØï‰ø°ÊÅØÊòæÁ§∫ÂÖÉÁ¥†
				const debugInfoElement = document.getElementById('photo-debug-info');
				const debugContentElement = debugInfoElement ? debugInfoElement.querySelector('.debug-content') : null;
				
				// ÈöêËóèË∞ÉËØï‰ø°ÊÅØÔºàÊØèÊ¨°Êñ∞Âä†ËΩΩÊó∂ÈáçÁΩÆÔºâ
				if (debugInfoElement) {
					debugInfoElement.classList.add('hidden');
				}
				
				// ËÆæÁΩÆÂä†ËΩΩÂ§±Ë¥•ÁöÑÂ§ÑÁêÜ
				imgElement.onerror = function() {
					// ÊûÑÂª∫ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØÔºà‰∏≠ÊñáÔºâ
					const errorTime = new Date().toLocaleTimeString('zh-CN');
					const encodedPath = encodeURI(pathToLoad);
					const encodedPathComponent = encodeURIComponent(pathToLoad);
					
					const errorDetails = [
						`[${errorTime}] ‚ùå ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: ${description}`,
						`   ÂéüÂßãË∑ØÂæÑ: ${pathToLoad}`,
						`   ÁºñÁ†ÅË∑ØÂæÑ(file:///${encodedPath})`,
						`   ÁºñÁ†ÅË∑ØÂæÑ(file:///${encodedPathComponent})`,
						`   ÂèØËÉΩÁöÑÂéüÂõ†:`,
						`   1. CEFÂÆâÂÖ®ÈôêÂà∂ÈòªÊ≠¢‰∫Üfile://ÂçèËÆÆ`,
						`   2. Êñá‰ª∂‰∏çÂ≠òÂú®ÊàñË∑ØÂæÑÈîôËØØ`,
						`   3. ‰∏≠ÊñáÂ≠óÁ¨¶ÁºñÁ†ÅÈóÆÈ¢ò`,
						`   4. Ë∑®ÂüüÈôêÂà∂(CORS)`,
						``,
						`   Âª∫ËÆÆËß£ÂÜ≥ÊñπÊ°à:`,
						`   1. ‰ΩøÁî®base64ÁºñÁ†ÅÊõø‰ª£file://ÂçèËÆÆ`,
						`   2. Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®: ${pathToLoad}`,
						`   3. ËÅîÁ≥ªÊèí‰ª∂ÂºÄÂèëËÄÖÂêØÁî®CEFË∞ÉËØï`
					].join('\n');
					
					// Âú®Ë∞ÉËØï‰ø°ÊÅØÂå∫ÂüüÊòæÁ§∫ÈîôËØØ
					if (debugInfoElement && debugContentElement) {
						debugContentElement.textContent = errorDetails;
						debugInfoElement.classList.remove('hidden');
					}
					
					// Âú®ÁÖßÁâáÂç†‰ΩçÁ¨¶Â§ÑÊòæÁ§∫ÁÆÄË¶ÅÈîôËØØ‰ø°ÊÅØ
					photoPlaceholder.classList.remove('hidden');
					photoPlaceholder.textContent = 'ÂõæÁâáÂä†ËΩΩÂ§±Ë¥• - Êü•Áúã‰∏ãÊñπË∞ÉËØï‰ø°ÊÅØ';
					photoPlaceholder.style.color = '#ff6b6b';
					photoDisplay.classList.add('hidden');
					photoNav.classList.remove('hidden');
					
					// Â∞ùËØï‰ΩøÁî®encodeURIComponentÂÜçÊ¨°Âä†ËΩΩÔºàËá™Âä®ÈáçËØïÔºâ
					setTimeout(() => {
						const retryPath = 'file:///' + encodeURIComponent(pathToLoad);
						if (debugContentElement) {
							debugContentElement.textContent += `\n\n‚è≥ Â∞ùËØïÈáçÊñ∞Âä†ËΩΩ: ${retryPath}`;
						}
						imgElement.src = retryPath;
					}, 1000);
				};
				
				// ËÆæÁΩÆÂä†ËΩΩÊàêÂäüÁöÑÂ§ÑÁêÜ
				imgElement.onload = function() {
					// ÈöêËóèË∞ÉËØï‰ø°ÊÅØ
					if (debugInfoElement) {
						debugInfoElement.classList.add('hidden');
					}
					
					// ÊòæÁ§∫ÂõæÁâáÂπ∂ÈöêËóèÂç†‰ΩçÁ¨¶
					photoDisplay.classList.remove('hidden');
					photoPlaceholder.classList.add('hidden');
					photoNav.classList.remove('hidden');
					
					// ÂèØÈÄâÔºöÂú®Ë∞ÉËØï‰ø°ÊÅØ‰∏≠ÊòæÁ§∫ÊàêÂäü‰ø°ÊÅØÔºà‰øùÊåÅÈöêËóèÔºâ
					if (debugContentElement) {
						debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] ‚úÖ ÂõæÁâáÂä†ËΩΩÊàêÂäü: ${description}\nË∑ØÂæÑ: ${pathToLoad}`;
					}
				};
				
				// ÂºÄÂßãÂä†ËΩΩÂõæÁâá
				imgElement.src = 'file:///' + encodeURI(pathToLoad);
				
				// ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
				if (debugContentElement) {
					debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] üì∏ ÂºÄÂßãÂä†ËΩΩÂõæÁâá: ${description}\nË∑ØÂæÑ: ${pathToLoad}`;
					debugInfoElement.classList.remove('hidden');
				}
			}
			
			function tryLoadPhotoWithBase64() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_GetPhotoBase64 === 'function' && currentElementGuid) {
					if (debugContentElement) {
						debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] üîÑ Â∞ùËØïbase64ÁºñÁ†ÅÂä†ËΩΩ: ${photoPath}`;
						debugInfoElement.classList.remove('hidden');
					}
					
					return ACAPI.ComponentInfo_GetPhotoBase64([currentElementGuid, photoPath])
						.then(function(base64Url) {
							if (base64Url && base64Url.length > 0 && base64Url.startsWith('data:image/')) {
								// ÊàêÂäüËé∑Âèñbase64Êï∞ÊçÆURL
								if (debugContentElement) {
									debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] ‚úÖ base64ÁºñÁ†ÅÊàêÂäü, ÈïøÂ∫¶: ${base64Url.length}`;
								}
								photoDisplay.src = base64Url;
								photoDisplay.classList.remove('hidden');
								photoPlaceholder.classList.add('hidden');
								photoNav.classList.remove('hidden');
								
								// ËÆæÁΩÆÊàêÂäüÂ§ÑÁêÜ
								photoDisplay.onload = function() {
									if (debugInfoElement) {
										debugInfoElement.classList.add('hidden');
									}
								};
								
								// ËÆæÁΩÆÂ§±Ë¥•Â§ÑÁêÜ
								photoDisplay.onerror = function() {
									if (debugContentElement) {
										debugContentElement.textContent += `\n‚ùå base64Êï∞ÊçÆURLÂä†ËΩΩÂ§±Ë¥•ÔºåÂ∞ùËØïfile://ÂõûÈÄÄ`;
									}
									tryLoadPhotoWithFileProtocol();
								};
								
								return true; // ÊàêÂäü
							} else {
								// base64ÁºñÁ†ÅÂ§±Ë¥•ÊàñÊó†ÊïàÊï∞ÊçÆ
								if (debugContentElement) {
									debugContentElement.textContent += `\n‚ö†Ô∏è base64ÁºñÁ†ÅËøîÂõûÊó†ÊïàÊï∞ÊçÆÔºåÂ∞ùËØïfile://ÂõûÈÄÄ`;
								}
								return tryLoadPhotoWithFileProtocol();
							}
						})
						.catch(function(err) {
							if (debugContentElement) {
								debugContentElement.textContent += `\n‚ö†Ô∏è base64ÁºñÁ†ÅÂ§±Ë¥•: ${err}, Â∞ùËØïfile://ÂõûÈÄÄ`;
							}
							return tryLoadPhotoWithFileProtocol();
						});
				} else {
					// base64 API‰∏çÂèØÁî®ÔºåÁõ¥Êé•‰ΩøÁî®file://
					if (debugContentElement) {
						debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] ‚ö†Ô∏è base64 API‰∏çÂèØÁî®Ôºå‰ΩøÁî®file://ÂçèËÆÆ`;
						debugInfoElement.classList.remove('hidden');
					}
					return tryLoadPhotoWithFileProtocol();
				}
			}
			
			function tryLoadPhotoWithFileProtocol() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_GetPhotoFullPath === 'function' && currentElementGuid) {
					return ACAPI.ComponentInfo_GetPhotoFullPath([currentElementGuid, photoPath])
						.then(function(fullPath) {
							if (fullPath && fullPath.length > 0) {
								loadPhotoWithErrorHandling(photoDisplay, fullPath, `ÂÆåÊï¥Ë∑ØÂæÑ (${currentPhotoIndex + 1}/${currentPhotoPaths.length})`);
							} else {
								loadPhotoWithErrorHandling(photoDisplay, photoPath, `Áõ∏ÂØπË∑ØÂæÑ (${currentPhotoIndex + 1}/${currentPhotoPaths.length})`);
							}
						})
						.catch(function(err) {
							loadPhotoWithErrorHandling(photoDisplay, photoPath, `Áõ∏ÂØπË∑ØÂæÑ(ÈîôËØØÂõûÈÄÄ) (${currentPhotoIndex + 1}/${currentPhotoPaths.length})`);
						});
				} else {
					loadPhotoWithErrorHandling(photoDisplay, photoPath, `Áõ∏ÂØπË∑ØÂæÑ(ACAPI‰∏çÂèØÁî®) (${currentPhotoIndex + 1}/${currentPhotoPaths.length})`);
				}
				return false; // ÂºÇÊ≠•Êìç‰ΩúÔºåËøîÂõûfalseË°®Á§∫‰∏çÊòØÁ´ãÂç≥ÊàêÂäü
			}
			
			// ÂºÄÂßãÂä†ËΩΩËøáÁ®ãÔºöÂÖàÂ∞ùËØïbase64ÔºåÂ§±Ë¥•ÂàôÂõûÈÄÄÂà∞file://
			tryLoadPhotoWithBase64();
		}
		
		function showNextPhoto() {
			if (currentPhotoIndex < currentPhotoPaths.length - 1) {
				showPhotoAtIndex(currentPhotoIndex + 1);
			}
		}
		
		function showPrevPhoto() {
			if (currentPhotoIndex > 0) {
				showPhotoAtIndex(currentPhotoIndex - 1);
			}
		}
		
		function updatePhotoPreview() {
			// Update photo preview based on current photo paths
			showPhotoAtIndex(0);
			
			// Enable/disable view photos button
			const viewPhotosBtn = document.getElementById('view-photos-btn');
			if (viewPhotosBtn) {
				viewPhotosBtn.disabled = !currentPhotoPaths || currentPhotoPaths.length === 0;
			}
		}
		
  		// Helper function to refresh component info display for current element
		function refreshComponentInfoDisplay() {
			if (!currentElementGuid) {
				return;
			}
			
			if (typeof ACAPI.ComponentInfo_GetComponentInfo === 'function') {
				ACAPI.ComponentInfo_GetComponentInfo(currentElementGuid).then(function (componentInfo) {
					if (componentInfo && componentInfo.componentId !== undefined) {
						document.getElementById('component-id').value = componentInfo.componentId || '';
						document.getElementById('photo-description').value = componentInfo.photoDescription || '';
						currentPhotoPaths = componentInfo.photoPaths || [];
						// Update photo paths display if needed
						if (currentPhotoPaths.length > 0) {
							document.getElementById('view-photos-btn').disabled = false;
							updatePhotoPreview();
						} else {
							document.getElementById('view-photos-btn').disabled = true;
						}
					} else {
						// No component info stored yet (should not happen after saving)
						console.log('No component info found after save, keeping current values');
					}
				}).catch(function (err) {
					console.error('Failed to refresh component info after save:', err);
					// Keep current values on refresh failure
				});
			}
		}
		
		function exitEditMode(save) {
			isEditMode = false;
			if (!save) {
				hasUnsavedChanges = false;
				updateUnsavedIndicator();
			}
			document.getElementById('component-id').disabled = true;
			document.getElementById('photo-description').disabled = true;
			document.getElementById('select-photos-btn').disabled = true;
			// Show edit button, hide save and cancel buttons
			document.getElementById('edit-info-btn').classList.remove('hidden');
			document.getElementById('edit-info-btn').textContent = 'ÁºñËæë‰ø°ÊÅØ';
			document.getElementById('save-info-btn').classList.add('hidden');
			document.getElementById('cancel-edit-btn').classList.add('hidden');
			document.getElementById('view-ifc-properties-btn').disabled = false;
			// Notify C++ backend about edit mode change
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_SetEditMode === 'function') {
				ACAPI.ComponentInfo_SetEditMode('false').catch(err => console.warn('Failed to set edit mode:', err));
			}
			
			if (save && currentElementGuid) {
				// Save component info using API
				const componentId = document.getElementById('component-id').value;
				const photoDescription = document.getElementById('photo-description').value;
				
				if (typeof ACAPI.ComponentInfo_SaveComponentInfo === 'function') {
					ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
						.then(function (success) {
							if (success) {
								console.log('Component info saved successfully');
								hasUnsavedChanges = false;
								updateUnsavedIndicator();
								// Refresh component info display to confirm save
								refreshComponentInfoDisplay();
								// Force update of selected elements to ensure all data is fresh
								setTimeout(function() {
									UpdateSelectedElements();
								}, 100);
							} else {
								console.error('Failed to save component info');
							}
						})
						.catch(function (err) {
							console.error('Error saving component info:', err);
						});
				} else {
					console.warn('ComponentInfo_SaveComponentInfo API not available');
				}
			}
		}
		
		// Event listeners
		document.addEventListener('DOMContentLoaded', function() {
			// Debug: log ACAPI availability
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('HTML loaded: Checking ACAPI availability');
			} else {
				console.log('HTML loaded: Checking ACAPI availability');
			}
			function updateBridgeStatus(isAvailable, funcs, version) {
				const statusEl = document.getElementById('bridge-status');
				if (!statusEl) return;
				if (isAvailable) {
					statusEl.textContent = `(Ê°•Êé•Â∞±Áª™, ${funcs.length} ‰∏™ÂáΩÊï∞)`;
					statusEl.style.color = '#10b981'; // success green
				} else {
					statusEl.textContent = '(Ê°•Êé•Êú™ËøûÊé•)';
					statusEl.style.color = '#ef4444'; // error red
				}
				if (version) {
					statusEl.textContent += ` v${version}`;
				}
			}
			
			if (typeof ACAPI !== 'undefined') {
				// Try to log via ACAPI.LogDebug if available
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('HTML loaded: ACAPI object is defined');
				} else {
					console.log('ACAPI object is defined');
				}
				
				// List available functions
				const funcs = Object.keys(ACAPI).filter(key => typeof ACAPI[key] === 'function');
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('ACAPI functions: ' + JSON.stringify(funcs));
				} else {
					console.log('ACAPI functions:', funcs);
				}
				updateBridgeStatus(true, funcs, null);
				
				// Try to call GetPluginVersion to test bridge
				if (ACAPI.GetPluginVersion) {
					ACAPI.GetPluginVersion().then(version => {
						if (typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Plugin version from ACAPI: ' + version);
						} else {
							console.log('Plugin version from ACAPI:', version);
						}
						updateBridgeStatus(true, funcs, version);
					}).catch(err => {
						if (typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Failed to get plugin version: ' + err);
						} else {
							console.error('Failed to get plugin version:', err);
						}
						updateBridgeStatus(true, funcs, 'error');
					});
				}
			}
			// Initialize unsaved changes indicator
			updateUnsavedIndicator();
			
			// Initialize plugin version display
			updatePluginVersion();
			
			// Search input for IFC properties
			const searchInput = document.getElementById('property-search');
			searchInput.addEventListener('input', function(e) {
				filterProperties(e.target.value.toLowerCase());
			});

			// ComponentInfo input change tracking
			const componentIdInput = document.getElementById('component-id');
			const photoDescriptionInput = document.getElementById('photo-description');
			
			componentIdInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});
			
			photoDescriptionInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});

			// Refresh button
			document.getElementById('refresh-btn').addEventListener('click', function() {
				// In real implementation, re-fetch properties for current selection
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});

			// Retry button for error state
			document.getElementById('retry-btn').addEventListener('click', function() {
				document.getElementById('error-state').classList.add('hidden');
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// View IFC Properties button
			document.getElementById('view-ifc-properties-btn').addEventListener('click', function() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// Edit info button
			document.getElementById('edit-info-btn').addEventListener('click', function() {
				enterEditMode();
			});
			
			// Save info button
			document.getElementById('save-info-btn').addEventListener('click', function() {
				exitEditMode(true); // Save changes
			});
			
			// Cancel edit button
			document.getElementById('cancel-edit-btn').addEventListener('click', function() {
				exitEditMode(false); // Cancel without saving
			});
			
			// Select photos button
			document.getElementById('select-photos-btn').addEventListener('click', function() {
				// Debug logging
				const debugInfo = {
					currentElementGuid: currentElementGuid,
					isEditMode: isEditMode,
					ACAPI_Available: typeof ACAPI !== 'undefined',
					ComponentInfo_SelectPhotos_Available: typeof ACAPI.ComponentInfo_SelectPhotos === 'function'
				};
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('ÈÄâÊã©ÁÖßÁâáÊåâÈíÆË¢´ÁÇπÂáª: ' + JSON.stringify(debugInfo));
				} else {
					console.log('ÈÄâÊã©ÁÖßÁâáÊåâÈíÆË¢´ÁÇπÂáª', debugInfo);
				}
				
				if (!currentElementGuid) {
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('ÈîôËØØ: No element selected (currentElementGuid is null)');
					} else {
						console.error('No element selected');
					}
					return;
				}
				
				if (typeof ACAPI.ComponentInfo_SelectPhotos === 'function') {
					ACAPI.ComponentInfo_SelectPhotos(currentElementGuid).then(function (selectedPaths) {
						if (selectedPaths && selectedPaths.length > 0) {
							// Append new photo paths to existing ones
							currentPhotoPaths = currentPhotoPaths.concat(selectedPaths);
							hasUnsavedChanges = true;
							updateUnsavedIndicator();
							// Save immediately with updated photo paths
							const componentId = document.getElementById('component-id').value;
							const photoDescription = document.getElementById('photo-description').value;
							
							ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
								.then(function (success) {
									if (success) {
										console.log('Photos added and saved successfully');
										hasUnsavedChanges = false;
										updateUnsavedIndicator();
										// Enable view photos button and update preview
										document.getElementById('view-photos-btn').disabled = false;
										updatePhotoPreview();
									} else {
										console.error('Failed to save photos');
									}
								})
								.catch(function (err) {
									console.error('Error saving photos:', err);
								});
						}
					}).catch(function (err) {
						console.error('Error selecting photos:', err);
					});
				} else {
					console.warn('ComponentInfo_SelectPhotos API not available');
				}
			});
			
			// View photos button - open current photo file
			document.getElementById('view-photos-btn').addEventListener('click', function() {
				if (!currentElementGuid) {
					console.error('No element selected');
					return;
				}
				
				if (!currentPhotoPaths || currentPhotoPaths.length === 0) {
					console.error('No photos available');
					return;
				}
				
				// Open the currently displayed photo file
				const currentPhotoPath = currentPhotoPaths[currentPhotoIndex];
				if (typeof ACAPI.ComponentInfo_ViewPhotos === 'function') {
					ACAPI.ComponentInfo_ViewPhotos([currentElementGuid, currentPhotoPath])
						.then(function (success) {
							if (!success) {
								console.error('Failed to open photo file');
							}
						})
						.catch(function (err) {
							console.error('Error opening photo file:', err);
						});
				} else {
					console.warn('ComponentInfo_ViewPhotos API not available');
				}
			});
			
			// Photo navigation buttons
			document.getElementById('prev-photo-btn').addEventListener('click', function() {
				showPrevPhoto();
			});
			
			document.getElementById('next-photo-btn').addEventListener('click', function() {
				showNextPhoto();
			});

			// Initial load - no element selected
			// Show empty state initially
			document.getElementById('empty-state').classList.remove('hidden');
			// Clear any previous properties
			currentProperties = [];
			const groups = groupProperties(currentProperties);
			renderPropertyGroups(groups);
			
			// Initial call to UpdateSelectedElements to get current selection
			UpdateSelectedElements();
			
			// Set up periodic selection update (every 250ms for faster response)
			setInterval(function() {
				UpdateSelectedElements();
			}, 250);
		});

		// Keep existing ACAPI bridge functions
		function UpdateSelectedElements() {
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					loadIFCProperties(elemInfos);
					
					// Update ComponentInfo fields
					if (elemInfos && elemInfos.length > 0) {
						const elem = elemInfos[0];
						const newElementGuid = elem[0]; // Get new GUID
						
						// Check if element has changed
						const elementChanged = (newElementGuid !== currentElementGuid);
						
						// If element changed and we're in edit mode, exit edit mode
						if (elementChanged && isEditMode) {
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('ÂÖÉÁ¥†ÂèòÂåñÊ£ÄÊµã: ‰ªé ' + currentElementGuid + ' ÂàáÊç¢Âà∞ ' + newElementGuid + ', ÈÄÄÂá∫ÁºñËæëÊ®°Âºè');
							} else {
								console.log('ÂÖÉÁ¥†ÂèòÂåñÊ£ÄÊµã: ‰ªé', currentElementGuid, 'ÂàáÊç¢Âà∞', newElementGuid, ', ÈÄÄÂá∫ÁºñËæëÊ®°Âºè');
							}
							// Exit edit mode without saving
							exitEditMode(false); // false = don't save
						}
						
						// Update current element GUID
						previousElementGuid = currentElementGuid;
						currentElementGuid = newElementGuid;
						
						// Debug logging
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('UpdateSelectedElements: ËÆæÁΩÆ currentElementGuid = ' + currentElementGuid + ', elemInfosÈïøÂ∫¶: ' + elemInfos.length + ', ÂÖÉÁ¥†ÂèòÂåñ: ' + elementChanged);
						} else {
							console.log('UpdateSelectedElements: ËÆæÁΩÆ currentElementGuid =', currentElementGuid, 'elemInfosÈïøÂ∫¶:', elemInfos.length, 'ÂÖÉÁ¥†ÂèòÂåñ:', elementChanged);
						}
						
						// Load component info if API is available
						// Only load component info if NOT in edit mode (to prevent overwriting user input)
						if (!isEditMode && typeof ACAPI.ComponentInfo_GetComponentInfo === 'function') {
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: ÈùûÁºñËæëÊ®°ÂºèÔºåÂä†ËΩΩÊûÑ‰ª∂‰ø°ÊÅØ');
							} else {
								console.log('UpdateSelectedElements: ÈùûÁºñËæëÊ®°ÂºèÔºåÂä†ËΩΩÊûÑ‰ª∂‰ø°ÊÅØ');
							}
							
							ACAPI.ComponentInfo_GetComponentInfo(currentElementGuid).then(function (componentInfo) {
								if (componentInfo && componentInfo.componentId !== undefined) {
									document.getElementById('component-id').value = componentInfo.componentId || '';
									document.getElementById('photo-description').value = componentInfo.photoDescription || '';
									currentPhotoPaths = componentInfo.photoPaths || [];
									// Update photo paths display if needed
									if (currentPhotoPaths.length > 0) {
										document.getElementById('view-photos-btn').disabled = false;
										updatePhotoPreview();
									} else {
										document.getElementById('view-photos-btn').disabled = true;
									}
									
									// Debug logging
									if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
										ACAPI.LogDebug('UpdateSelectedElements: Âä†ËΩΩÊûÑ‰ª∂‰ø°ÊÅØÊàêÂäüÔºåÊûÑ‰ª∂ÁºñÂè∑="' + componentInfo.componentId + '"');
									}
								} else {
									// No component info stored yet - keep existing values if any
									// Don't clear fields, just log
									if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
										ACAPI.LogDebug('UpdateSelectedElements: ÊûÑ‰ª∂Êó†‰øùÂ≠ò‰ø°ÊÅØÔºå‰øùÊåÅÂΩìÂâçÂÄº');
									} else {
										console.log('UpdateSelectedElements: ÊûÑ‰ª∂Êó†‰øùÂ≠ò‰ø°ÊÅØÔºå‰øùÊåÅÂΩìÂâçÂÄº');
									}
									// Only initialize empty fields if they're currently empty
									const componentIdInput = document.getElementById('component-id');
									const photoDescInput = document.getElementById('photo-description');
									if (!componentIdInput.value) componentIdInput.value = '';
									if (!photoDescInput.value) photoDescInput.value = '';
									currentPhotoPaths = [];
									document.getElementById('view-photos-btn').disabled = true;
									updatePhotoPreview();
								}
							}).catch(function (err) {
								console.error('Failed to load component info:', err);
								// Don't clear fields on error
								if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
									ACAPI.LogDebug('UpdateSelectedElements: Âä†ËΩΩÊûÑ‰ª∂‰ø°ÊÅØÂ§±Ë¥•Ôºå‰øùÊåÅÂΩìÂâçÂÄºÔºåÈîôËØØ: ' + err);
								}
							});
						} else if (isEditMode) {
							// In edit mode - don't load component info to prevent overwriting user input
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: ÁºñËæëÊ®°Âºè‰∏≠ÔºåË∑≥ËøáÊûÑ‰ª∂‰ø°ÊÅØÂä†ËΩΩ');
							} else {
								console.log('UpdateSelectedElements: ÁºñËæëÊ®°Âºè‰∏≠ÔºåË∑≥ËøáÊûÑ‰ª∂‰ø°ÊÅØÂä†ËΩΩ');
							}
						} else {
							// ComponentInfo_GetComponentInfo API not available
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: ComponentInfo_GetComponentInfo API ‰∏çÂèØÁî®');
							}
						}
					} else {
						// No element selected
						currentElementGuid = null;
						
						// Debug logging
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('UpdateSelectedElements: Ê≤°ÊúâÈÄâÊã©ÂÖÉÁ¥†ÔºåËÆæÁΩÆ currentElementGuid = null');
						} else {
							console.log('UpdateSelectedElements: Ê≤°ÊúâÈÄâÊã©ÂÖÉÁ¥†ÔºåËÆæÁΩÆ currentElementGuid = null');
						}
						
						document.getElementById('component-id').value = '';
						document.getElementById('photo-description').value = '';
						document.getElementById('view-photos-btn').disabled = true;
					}
				});
			}
		}

		function UpdateIFCProperties() {
			// Refresh properties for currently selected element(s)
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					loadIFCProperties(elemInfos);
				});
			}
		}
	</script>
</body>
</html>
