<!DOCTYPE html>
<html>
<head>
	<title>HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…·</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	<style type="text/css">
		/* CSS Variables for Industrial Dark Theme */
		:root {
			--bg-dark: #1a1d23;
			--bg-card: #252a33;
			--text-primary: #e2e8f0;
			--text-secondary: #a8b4cc; /* Improved contrast: 5.8:1 on --bg-dark (was #94a3b8, 4.5:1) */
			--accent: #0ea5e9; /* Improved contrast: 4.6:1 on --bg-card (was #06b6d4, 3.2:1) */
			--accent-hover: #38bdf8; /* Lighter for hover (was #22d3ee) */
			--border: #3f4a5c;
			--hover: #2d3748;
			--shadow: rgba(0, 0, 0, 0.3);
			--success: #10b981;
			--warning: #f59e0b;
			--error: #ef4444;
			--radius: 4px;
			--border-width: 1px;
			--border-width-md: 2px;
			--border-width-lg: 3px;
			--outline-width: 2px;
			--outline-width-lg: 3px;
			--shadow-sm: 0 2px 4px;
			--shadow-md: 0 0 0 3px;
			--transition: all 0.2s ease;
			/* New variables for better hierarchy (optional, can be added later) */
			--text-tertiary: #64748b; /* For less important text */
		}

		/* ========== TYPOGRAPHY & SPACING SCALE ========== */
		:root {
			/* Typography scale */
			--font-size-xxs: 9px; /* For very small text like debug info */
			--font-size-xs: 11px;
			--font-size-sm: 12px;
			--font-size-base: 13px;
			--font-size-md: 14px;
			--font-size-lg: 16px;
			--font-size-xl: 20px;
			--font-size-2xl: 24px;
			
			/* Spacing scale */
			--spacing-xs: 4px;
			--spacing-sm: 8px;
			--spacing-md: 12px;
			--spacing-lg: 16px;
			--spacing-xl: 20px;
			--spacing-2xl: 24px;
			--palette-min-width: var(--palette-min-width);
			--palette-min-height: var(--palette-min-height);
		}

		/* Base Reset */
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
			background-color: var(--bg-dark);
			color: var(--text-primary);
			font-size: var(--font-size-base);
			line-height: 1.4;
			padding: var(--spacing-md);
			min-width: var(--palette-min-width);
			min-height: var(--palette-min-height);
			overflow-x: auto;
			user-select: none;
		}

		/* ========== çŠ¶æ€ç±»å®šä¹‰ ========== */
		
		/* çŠ¶æ€1ï¼šæœªé€‰æ‹©æ„ä»¶ */
		.state-no-selection .group-2 .guid-value,
		.state-no-selection .group-2 .type-value,
		.state-no-selection .group-3 .form-input,
		.state-no-selection .group-3 .photo-preview,
		.state-no-selection .group-3 .controls button {
			/* æ˜¾ç¤º"æœªé€‰æ‹©æ„ä»¶"æç¤º */
		}
		
		.state-no-selection .group-2 .no-selection-message {
			display: block;
		}
		.state-no-selection .group-2 .guid-value,
		.state-no-selection .group-2 .type-value {
			display: none;
		}
		
		.state-no-selection .group-3 .no-info-message {
			display: none;
		}
		.state-no-selection .group-3 .has-info-content {
			display: none;
		}
		
		/* çŠ¶æ€2ï¼šå·²é€‰æ‹©æ„ä»¶æ— ä¿¡æ¯ */
		.state-no-info .group-2 .no-selection-message {
			display: none;
		}
		.state-no-info .group-2 .guid-value,
		.state-no-info .group-2 .type-value {
			display: block;
		}
		.state-no-info .group-3 .no-info-message {
			display: block;
		}
		.state-no-info .group-3 .has-info-content {
			display: none;
		}
		
		/* çŠ¶æ€3ï¼šå·²é€‰æ‹©æ„ä»¶æœ‰ä¿¡æ¯ */
		.state-has-info .group-2 .no-selection-message {
			display: none;
		}
		.state-has-info .group-2 .guid-value,
		.state-has-info .group-2 .type-value {
			display: block;
		}
		.state-has-info .group-3 .no-info-message {
			display: none;
		}
		.state-has-info .group-3 .has-info-content {
			display: block;
		}

		/* ========== ç¬¬ä¸€ç»„ä¿¡æ¯ï¼šæ ‡é¢˜å’Œç‰ˆæœ¬å· ========== */
		.group-1 {
			background: var(--bg-card);
			border-radius: var(--radius);
			padding: var(--spacing-lg);
			margin-bottom: var(--spacing-lg);
			border: var(--border-width) solid var(--border);
			box-shadow: var(--shadow-sm) var(--shadow);
		}

		.plugin-title {
			font-size: var(--font-size-xl); /* 20px */
			font-weight: 600;
			color: var(--accent);
			margin-bottom: var(--spacing-sm); /* 8px */
			padding-bottom: var(--spacing-sm); /* 8px */
			border-bottom: var(--border-width-md) solid var(--border);
			display: flex;
			align-items: center;
			gap: var(--spacing-sm); /* 8px */
		}

		.plugin-title::before {
			content: 'ğŸ—ï¸';
			font-size: calc(var(--font-size-xl) - var(--border-width-md)); /* 18px */
		}

		.version-display {
			font-size: var(--font-size-sm); /* 12px */
			color: var(--text-secondary);
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			margin-top: var(--spacing-xs); /* 4px */
		}

		/* ========== ç¬¬äºŒç»„ä¿¡æ¯ï¼šGUIDå’ŒTYPEæ˜¾ç¤º ========== */
		.group-2 {
			background: var(--bg-card);
			border-radius: var(--radius);
			padding: var(--spacing-lg);
			margin-bottom: var(--spacing-lg);
			border: var(--border-width) solid var(--border);
		}

		.group-2 h2 {
			font-size: var(--font-size-md); /* 14px */
			color: var(--accent);
			margin-bottom: var(--spacing-md); /* 12px */
			display: flex;
			align-items: center;
			gap: var(--spacing-sm);
		}

		.group-2 h2::before {
			content: '';
			display: inline-block;
			width: var(--spacing-md); /* 12px */
			height: var(--spacing-md); /* 12px */
			background-color: var(--accent);
			border-radius: calc(var(--radius) / 2);
		}

		.guid-type-container {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: var(--spacing-md);
		}

		.guid-item, .type-item {
			display: flex;
			flex-direction: column;
		}

		.guid-label, .type-label {
			font-size: var(--font-size-xs);
			color: var(--text-secondary);
			text-transform: uppercase;
			letter-spacing: 0.05em;
			margin-bottom: var(--spacing-xs);
		}

		.guid-value, .type-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			font-size: var(--font-size-sm);
			background: rgba(0, 0, 0, 0.2);
			padding: var(--spacing-sm) var(--spacing-xl);
			border-radius: var(--radius);
			border-left: var(--border-width-lg) solid var(--accent);
			word-break: break-all;
			min-height: calc(var(--spacing-lg) * 2); /* 32px (16px * 2) */
			display: flex;
			align-items: center;
		}

		.no-selection-message {
			font-size: var(--font-size-sm);
			color: var(--text-secondary);
			font-style: italic;
			text-align: center;
			padding: var(--spacing-md);
			background: rgba(148, 163, 184, 0.1);
			border-radius: var(--radius);
			grid-column: 1 / span 2;
		}

		/* ========== ç¬¬ä¸‰ç»„ä¿¡æ¯ï¼šæ„ä»¶ä¿¡æ¯å¡«å†™ç•Œé¢å’Œç…§ç‰‡åŠŸèƒ½ ========== */
		.group-3 {
			background: var(--bg-card);
			border-radius: var(--radius);
			padding: var(--spacing-lg);
			border: var(--border-width) solid var(--border);
		}

		.group-3 h2 {
			font-size: var(--font-size-md); /* 14px */
			color: var(--accent);
			margin-bottom: var(--spacing-md); /* 12px */
			display: flex;
			align-items: center;
			gap: var(--spacing-sm);
		}

		.group-3 h2::before {
			content: '';
			display: inline-block;
			width: var(--spacing-md); /* 12px */
			height: var(--spacing-md); /* 12px */
			background-color: var(--accent);
			border-radius: calc(var(--radius) / 2);
		}

		/* çŠ¶æ€æ¶ˆæ¯ */
		.no-info-message {
			font-size: var(--font-size-sm);
			color: var(--text-secondary);
			font-style: italic;
			text-align: center;
			padding: var(--spacing-lg);
			background: rgba(148, 163, 184, 0.1);
			border-radius: var(--radius);
			margin-bottom: var(--spacing-lg);
		}

		/* è¡¨å•ç»„ */
		.form-group {
			margin-bottom: var(--spacing-lg); /* 16px */
		}

		.form-label {
			display: block;
			font-size: var(--font-size-sm);
			color: var(--text-secondary);
			margin-bottom: var(--spacing-sm);
			font-weight: 500;
		}

		.form-input {
			width: 100%;
			padding: var(--spacing-sm) var(--spacing-md);
			background: var(--bg-dark);
			border: var(--border-width) solid var(--border);
			border-radius: var(--radius);
			color: var(--text-primary);
			font-size: var(--font-size-base);
			transition: var(--transition);
		}

		.form-input:focus {
			outline: var(--outline-width) solid var(--accent);
			outline-offset: var(--border-width);
			border-color: var(--accent);
			box-shadow: var(--shadow-md) rgba(6, 182, 212, 0.2);
		}

		.form-input:disabled {
			background: rgba(26, 29, 35, 0.5);
			color: var(--text-secondary);
			cursor: not-allowed;
		}

		.form-input::placeholder {
			color: var(--text-secondary);
		}

		/* ç…§ç‰‡é¢„è§ˆ */
		.photo-preview-container {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-sm);
		}

		.photo-preview {
			width: 100%;
			height: 200px;
			background: rgba(0, 0, 0, 0.2);
			border: 1px dashed var(--border);
			border-radius: var(--radius);
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
		}

		.photo-preview img {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
		}

		.photo-preview-placeholder {
			color: var(--text-secondary);
			font-size: var(--font-size-sm);
			text-align: center;
		}

		.photo-navigation {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: var(--spacing-md);
		}

		.photo-nav-btn {
			background: var(--bg-card);
			border: var(--border-width) solid var(--border);
			color: var(--text-primary);
			width: calc(var(--spacing-lg) + var(--spacing-md)); /* 28px (16px + 12px) */
			height: calc(var(--spacing-lg) + var(--spacing-md)); /* 28px (16px + 12px) */
			border-radius: var(--radius);
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: var(--font-size-md);
			transition: var(--transition);
		}

		.photo-nav-btn:hover:not(:disabled) {
			background: var(--hover);
			border-color: var(--accent);
		}

		.photo-nav-btn:disabled {
			opacity: 0.4;
			cursor: not-allowed;
		}
		
		.photo-nav-btn:focus-visible {
			outline: var(--outline-width-lg) solid var(--accent);
			outline-offset: var(--outline-width-lg);
			box-shadow: 0 0 0 5px rgba(6, 182, 212, 0.3);
		}

		.photo-index {
			font-size: var(--font-size-sm);
			color: var(--text-secondary);
			min-width: 60px;
			text-align: center;
		}

		.photo-debug-info {
			font-size: var(--font-size-xs);
			color: #ff6b6b;
			background: rgba(255, 107, 107, 0.1);
			border: 1px solid rgba(255, 107, 107, 0.3);
			border-radius: var(--radius);
			padding: var(--spacing-sm) var(--spacing-xs);
			margin-top: var(--spacing-xs);
			display: flex;
			flex-direction: column;
			gap: 2px; /* Too small for --spacing-xs (4px), keep as is */
		}

		.debug-header {
			font-weight: bold;
			color: #ff6b6b;
			font-size: var(--font-size-xs);
		}

		.debug-content {
			font-size: var(--font-size-xxs); /* 9px - for debug information */
			color: #ffa8a8;
			white-space: pre-wrap;
			word-break: break-all;
			max-height: 60px;
			overflow-y: auto;
		}

		/* æ§åˆ¶æŒ‰é’® */
		.controls {
			display: flex;
			gap: var(--spacing-sm);
			margin-top: var(--spacing-lg); /* 16px */
		}

		button {
			background: var(--accent);
			color: white;
			border: none;
			padding: var(--spacing-sm) var(--spacing-lg);
			border-radius: var(--radius);
			font-size: var(--font-size-sm);
			font-weight: 500;
			cursor: pointer;
			transition: var(--transition);
			display: inline-flex;
			align-items: center;
			gap: var(--spacing-xs);
			white-space: nowrap;
			flex: 1;
		}

		button:hover {
			background: var(--accent-hover);
			transform: translateY(-1px);
			box-shadow: var(--shadow-sm) var(--shadow);
		}

		button:active {
			transform: translateY(0);
		}
		
		button:focus-visible {
			outline: var(--outline-width-lg) solid var(--accent);
			outline-offset: var(--outline-width-lg);
			box-shadow: 0 0 0 6px rgba(6, 182, 212, 0.3);
		}

		button.secondary {
			background: transparent;
			border: var(--border-width) solid var(--border);
			color: var(--text-secondary);
		}

		button.secondary:hover {
			background: var(--hover);
			color: var(--text-primary);
		}

		button:disabled {
			background: rgba(6, 182, 212, 0.3);
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		button.secondary:disabled {
			background: transparent;
			border-color: rgba(63, 74, 92, 0.5);
			color: rgba(148, 163, 184, 0.5);
		}

		/* æœªä¿å­˜æ›´æ”¹æŒ‡ç¤ºå™¨ */
		.unsaved-indicator {
			color: var(--warning);
			font-weight: bold;
			margin-left: var(--border-width-md);
		}

		/* ç¼–è¾‘æ¨¡å¼æŒ‰é’® */
		.edit-mode-buttons {
			display: flex;
			gap: var(--spacing-sm);
			margin-top: var(--spacing-md); /* 12px */
			padding-top: var(--spacing-md); /* 12px */
			border-top: 1px solid var(--border);
		}

		/* IFCå±æ€§éƒ¨åˆ† */
		.ifc-properties-section {
			margin-top: var(--spacing-lg); /* 16px */
			padding-top: var(--spacing-lg); /* 16px */
			border-top: 1px solid var(--border);
		}

		.ifc-properties-section h3 {
			font-size: var(--font-size-base);
			color: var(--accent);
			margin-bottom: var(--spacing-md);
			display: flex;
			align-items: center;
			gap: var(--spacing-sm);
		}

		.ifc-properties-section h3::before {
			content: '';
			display: inline-block;
			width: var(--spacing-md); /* 12px */
			height: var(--spacing-md); /* 12px */
			background-color: var(--accent);
			border-radius: calc(var(--radius) / 2);
		}

		.ifc-controls {
			display: flex;
			gap: var(--spacing-sm);
			margin-bottom: var(--spacing-md); /* 12px */
		}

		.search-box {
			flex: 1;
			position: relative;
		}

		.search-box input {
			width: 100%;
			padding: var(--spacing-sm) var(--spacing-xl) var(--spacing-sm) 32px;
			background: var(--bg-dark);
			border: var(--border-width) solid var(--border);
			border-radius: var(--radius);
			color: var(--text-primary);
			font-size: var(--font-size-sm);
			transition: var(--transition);
		}

		.search-box input:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
		}

		.search-box::before {
			content: 'ğŸ”';
			position: absolute;
			left: 10px;
			top: 50%;
			transform: translateY(-50%);
			font-size: var(--font-size-sm);
			color: var(--text-secondary);
			pointer-events: none;
		}

		/* Property Groups */
		.property-groups {
			margin-top: var(--spacing-lg);
			overflow-x: auto;
			max-width: 100%;
		}

		.group {
			background: var(--bg-card);
			border-radius: var(--radius);
			border: var(--border-width) solid var(--border);
			margin-bottom: var(--spacing-xl);
			overflow: hidden;
		}

		.group-header {
			padding: var(--spacing-xl) var(--spacing-md);
			background: rgba(63, 74, 92, 0.3);
			display: flex;
			justify-content: space-between;
			align-items: center;
			cursor: pointer;
			transition: var(--transition);
		}

		.group-header:hover {
			background: rgba(63, 74, 92, 0.5);
		}
		
		.group-header:focus-visible {
			outline: var(--outline-width) solid var(--accent);
			outline-offset: -2px;
			background: rgba(63, 74, 92, 0.7);
		}

		.group-header h3 {
			font-size: var(--font-size-base);
			font-weight: 600;
			color: var(--text-primary);
		}

		.group-badge {
			background: var(--accent);
			color: white;
			font-size: var(--font-size-xs);
			padding: 2px var(--spacing-sm);
			border-radius: 10px;
			font-weight: 600;
		}

		.group-content {
			padding: 0;
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease;
		}

		.group.expanded .group-content {
			max-height: 2000px;
		}

		/* Property Table */
		.property-table {
			width: 100%;
			border-collapse: collapse;
			font-size: var(--font-size-sm);
		}

		.property-table thead {
			background: rgba(0, 0, 0, 0.2);
			border-bottom: var(--border-width-md) solid var(--border);
		}

		.property-table th {
			padding: var(--spacing-sm) var(--spacing-xl);
			text-align: left;
			font-weight: 600;
			color: var(--text-secondary);
			text-transform: uppercase;
			font-size: var(--font-size-xs);
			letter-spacing: 0.05em;
		}

		.property-table tbody tr {
			border-bottom: 1px solid rgba(63, 74, 92, 0.3);
			transition: var(--transition);
		}

		.property-table tbody tr:hover {
			background: var(--hover);
		}

		.property-table td {
			padding: var(--spacing-sm) var(--spacing-xl);
			vertical-align: top;
		}

		.property-name {
			font-weight: 500;
			color: var(--text-primary);
			min-width: 140px;
		}

		.property-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			color: var(--accent);
			word-break: break-word;
			max-width: 200px;
		}

		.property-type {
			color: var(--text-secondary);
			font-style: italic;
			font-size: var(--font-size-xs);
		}

		.property-unit {
			color: var(--success);
			font-size: var(--font-size-xs);
		}

		/* Empty & Loading States */
		.empty-state, .loading-state {
			text-align: center;
			padding: var(--spacing-2xl) var(--spacing-xl);
			color: var(--text-secondary);
		}

		.empty-state h3, .loading-state h3 {
			color: var(--text-secondary);
			margin-bottom: var(--spacing-sm); /* 8px */
		}

		/* Warning Notification */
		.warning-notice {
			background: rgba(245, 158, 11, 0.1);
			border: 1px solid var(--warning);
			border-radius: var(--radius);
			padding: var(--spacing-sm) var(--spacing-md);
			margin: var(--spacing-xl) 0;
			color: var(--warning);
			font-size: var(--font-size-sm);
			display: flex;
			align-items: center;
			gap: var(--spacing-sm);
		}
		.warning-notice::before {
			content: 'âš ï¸';
			font-size: var(--font-size-md);
		}

		/* Error Notification */
		.error-notice {
			background: rgba(239, 68, 68, 0.1);
			border: 1px solid var(--error);
			border-radius: var(--radius);
			padding: var(--spacing-sm) var(--spacing-md);
			margin: var(--spacing-xl) 0;
			color: var(--error);
			font-size: var(--font-size-sm);
			display: flex;
			align-items: center;
			gap: var(--spacing-sm);
		}
		.error-notice::before {
			content: 'âŒ';
			font-size: var(--font-size-md);
		}

		/* éšè—ç±» */
		.hidden {
			display: none !important;
		}

		.fade-in {
			animation: fadeIn 0.3s ease;
		}
		
		/* å±å¹•é˜…è¯»å™¨ä¸“ç”¨ç±» */
		.sr-only {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0, 0, 0, 0);
			white-space: nowrap;
			border: 0;
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		/* å“åº”å¼ */
		@media (max-width: 500px) {
			.guid-type-container {
				grid-template-columns: 1fr;
			}
			
			.no-selection-message {
				grid-column: 1;
			}
			
			.controls, .ifc-controls {
				flex-wrap: wrap;
			}
			
			button {
				flex: 0 0 calc(50% - var(--spacing-xs));
			}
			
			.property-table {
				display: block;
				overflow-x: auto;
			}
			
			/* Confirmation dialog styles */
			.confirmation-dialog {
				background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
				border: var(--border-width) solid var(--border);
				border-radius: 6px;
				padding: var(--spacing-lg);
				margin-top: var(--spacing-md);
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
			}
			
			.confirmation-dialog.hidden {
				display: none;
			}
			
			.confirmation-content p {
				margin: 0 0 var(--spacing-lg) 0;
				color: var(--text);
			font-size: var(--font-size-md);
				line-height: 1.5;
			}
			
			.confirmation-buttons {
				display: flex;
				gap: var(--spacing-sm);
				justify-content: flex-end;
			}
			
			.confirmation-buttons button {
				flex: 0 0 auto;
				min-width: 80px;
			}
			
			/* Edit mode notification styles */
			.edit-mode-notification {
				background: linear-gradient(135deg, #3a2c1c 0%, #2d2318 100%);
				border: 1px solid #d97706;
				border-radius: 6px;
				padding: var(--spacing-xl) var(--spacing-lg);
				margin: var(--spacing-md) 0;
				box-shadow: 0 2px 8px rgba(217, 119, 6, 0.2);
			}
			
			.edit-mode-notification.hidden {
				display: none;
			}
			
			.notification-content {
				display: flex;
				align-items: center;
				gap: var(--spacing-xl);
			}
			
			.notification-icon {
				font-size: var(--font-size-lg);
			}
			
			.notification-text {
				color: #fbbf24;
				font-size: var(--font-size-base);
				line-height: 1.4;
				flex: 1;
			}
		}
	</style>
</head>
<body class="state-no-selection" role="application" aria-label="HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…·">
	<!-- ç¬¬ä¸€ç»„ä¿¡æ¯ï¼šæ ‡é¢˜å’Œç‰ˆæœ¬å· -->
	<div class="group-1" role="banner" aria-label="æ’ä»¶æ ‡é¢˜å’Œç‰ˆæœ¬ä¿¡æ¯">
		<div class="plugin-title" id="version-display" role="heading" aria-level="1">HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…· (V0.0.0.0)</div>
		<div class="version-display" aria-label="åŸºäºArchiCAD API Development Kit 29.3100">åŸºäºArchiCAD API Development Kit 29.3100</div>
	</div>

	<!-- ç¬¬äºŒç»„ä¿¡æ¯ï¼šGUIDå’ŒTYPEæ˜¾ç¤º -->
	<div class="group-2" role="region" aria-label="æ„ä»¶æ ‡è¯†ä¿¡æ¯">
		<h2 id="element-identification-heading">æ„ä»¶æ ‡è¯†</h2>
		<div class="guid-type-container" role="group" aria-labelledby="element-identification-heading">
			<div class="guid-item" role="region" aria-label="æ„ä»¶å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦">
				<div class="guid-label" id="guid-label">GUID</div>
				<div id="summary-guid" class="guid-value" role="status" aria-labelledby="guid-label" aria-live="polite">{GUID}</div>
			</div>
			<div class="type-item" role="region" aria-label="æ„ä»¶ç±»å‹">
				<div class="type-label" id="type-label">TYPE</div>
				<div id="summary-type" class="type-value" role="status" aria-labelledby="type-label" aria-live="polite">{Element Type}</div>
			</div>
			<div class="no-selection-message" id="no-selection-message" role="alert" aria-live="assertive">æœªé€‰æ‹©æ„ä»¶</div>
		</div>
	</div>
	
	<!-- ç¼–è¾‘æ¨¡å¼é€šçŸ¥æ ï¼ˆå½“å¤„äºç¼–è¾‘æ¨¡å¼æ—¶æ˜¾ç¤ºï¼‰ -->
	<div id="edit-mode-notification" class="edit-mode-notification hidden" role="alert" aria-live="assertive" aria-label="ç¼–è¾‘æ¨¡å¼é€šçŸ¥">
		<div class="notification-content">
			<span class="notification-icon" aria-hidden="true">âš ï¸</span>
			<span class="notification-text">å½“å‰å¤„äºç¼–è¾‘æ¨¡å¼ã€‚è¯·ä¿å­˜æˆ–å–æ¶ˆç¼–è¾‘åæ‰èƒ½é€‰æ‹©å…¶ä»–æ„ä»¶ã€‚</span>
		</div>
	</div>

	<!-- ç¬¬ä¸‰ç»„ä¿¡æ¯ï¼šæ„ä»¶ä¿¡æ¯å¡«å†™ç•Œé¢å’Œç…§ç‰‡åŠŸèƒ½ -->
	<div class="group-3" role="main" aria-label="æ„ä»¶ä¿¡æ¯ç®¡ç†">
		<h2 id="component-info-heading">æ„ä»¶ä¿¡æ¯ <span id="componentinfo-unsaved-indicator" class="unsaved-indicator hidden" aria-label="æœ‰æœªä¿å­˜çš„æ›´æ”¹" aria-hidden="true">*</span></h2>
		
		<!-- çŠ¶æ€2æ¶ˆæ¯ï¼šå·²é€‰æ‹©æ„ä»¶æ— ä¿¡æ¯ -->
		<div class="no-info-message" id="no-info-message" role="status" aria-live="polite" aria-atomic="true">
			è¯·å¡«å†™æ„ä»¶ç¼–å·å’Œç…§ç‰‡æè¿°ä¿¡æ¯
			<div style="margin-top: var(--spacing-md);">
				<button id="add-info-btn" class="secondary" role="button" aria-label="æ·»åŠ æ„ä»¶ä¿¡æ¯" tabindex="0">æ·»åŠ ä¿¡æ¯</button>
			</div>
		</div>
		
		<!-- çŠ¶æ€3å†…å®¹ï¼šå·²é€‰æ‹©æ„ä»¶æœ‰ä¿¡æ¯ -->
		<div class="has-info-content">
			<!-- æ„ä»¶ç¼–å·è¾“å…¥æ¡† -->
			<div class="form-group">
				<label class="form-label" for="component-id" id="component-id-label">æ„ä»¶ç¼–å·</label>
				<input type="text" id="component-id" class="form-input" placeholder="è¯·å¡«å†™æ„ä»¶ç¼–å·" disabled
					aria-labelledby="component-id-label" aria-describedby="component-id-description" tabindex="-1"
					aria-readonly="true" aria-invalid="false">
				<div id="component-id-description" class="sr-only">è¾“å…¥æ„ä»¶çš„å”¯ä¸€ç¼–å·æ ‡è¯†</div>
			</div>
			
			<!-- ç…§ç‰‡æè¿°è¾“å…¥æ¡† -->
			<div class="form-group">
				<label class="form-label" for="photo-description" id="photo-description-label">ç…§ç‰‡æè¿°</label>
				<input type="text" id="photo-description" class="form-input" placeholder="è¯·è¾“å…¥ç…§ç‰‡æè¿°" disabled
					aria-labelledby="photo-description-label" aria-describedby="photo-description-description" tabindex="-1"
					aria-readonly="true" aria-invalid="false">
				<div id="photo-description-description" class="sr-only">è¾“å…¥ç…§ç‰‡çš„æè¿°ä¿¡æ¯</div>
			</div>
			
			<!-- ç…§ç‰‡é¢„è§ˆ -->
			<div class="form-group">
				<label class="form-label" id="photo-preview-label">ç…§ç‰‡é¢„è§ˆ</label>
				<div class="photo-preview-container" role="region" aria-labelledby="photo-preview-label">
					<div class="photo-preview" role="img" aria-label="ç…§ç‰‡é¢„è§ˆåŒºåŸŸ">
						<div class="photo-preview-placeholder" id="photo-placeholder-text">æœªé€‰æ‹©ç…§ç‰‡</div>
						<img id="photo-display" src="" alt="ç…§ç‰‡é¢„è§ˆ" class="hidden" aria-describedby="photo-index">
					</div>
					<div class="photo-navigation hidden" role="group" aria-label="ç…§ç‰‡å¯¼èˆª">
						<button id="prev-photo-btn" class="photo-nav-btn" disabled role="button" aria-label="ä¸Šä¸€å¼ ç…§ç‰‡" tabindex="-1" aria-disabled="true">â€¹</button>
						<span id="photo-index" class="photo-index" role="status" aria-live="polite">0 / 0</span>
						<button id="next-photo-btn" class="photo-nav-btn" disabled role="button" aria-label="ä¸‹ä¸€å¼ ç…§ç‰‡" tabindex="-1" aria-disabled="true">â€º</button>
					</div>
					<!-- è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ -->
					<div id="photo-debug-info" class="photo-debug-info hidden" role="status" aria-live="polite">
						<div class="debug-header">è°ƒè¯•ä¿¡æ¯ (F12æ§åˆ¶å°ä¸å¯ç”¨æ—¶ä½¿ç”¨):</div>
						<div class="debug-content"></div>
					</div>
					<!-- ç…§ç‰‡åŠ è½½çŠ¶æ€å…¬å‘Š -->
					<div id="photo-loading-status" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>
				</div>
			</div>
			
			<!-- æ§åˆ¶æŒ‰é’® -->
			<div class="controls" role="group" aria-label="æ„ä»¶ä¿¡æ¯æ“ä½œæŒ‰é’®">
				<!-- ç…§ç‰‡åŠŸèƒ½å¸®åŠ©æ–‡æœ¬ -->
				<div id="photo-functionality-help" class="help-text">
					<span id="global-id-status" class="status-indicator"></span>
				</div>
				<button id="select-photos-btn" class="secondary" disabled role="button" aria-label="é€‰æ‹©ç…§ç‰‡" tabindex="0" aria-disabled="true" aria-describedby="select-photos-tooltip">é€‰æ‹©ç…§ç‰‡</button>
				<button id="view-photos-btn" class="secondary" disabled role="button" aria-label="æŸ¥çœ‹ç…§ç‰‡" tabindex="0" aria-disabled="true" aria-describedby="view-photos-tooltip">æŸ¥çœ‹ç…§ç‰‡</button>
				<button id="edit-info-btn" role="button" aria-label="ç¼–è¾‘æ„ä»¶ä¿¡æ¯" tabindex="0">ç¼–è¾‘ä¿¡æ¯</button>
				<div id="select-photos-tooltip" class="sr-only" aria-live="polite"></div>
				<div id="view-photos-tooltip" class="sr-only" aria-live="polite"></div>
			</div>
			
			<!-- ç¼–è¾‘æ¨¡å¼æŒ‰é’®ï¼ˆé»˜è®¤éšè—ï¼‰ -->
			<div class="edit-mode-buttons hidden" role="group" aria-label="ç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®">
				<button id="save-info-btn" class="hidden" role="button" aria-label="ä¿å­˜æ„ä»¶ä¿¡æ¯" tabindex="-1">ä¿å­˜</button>
				<button id="cancel-edit-btn" class="secondary hidden" role="button" aria-label="å–æ¶ˆç¼–è¾‘" tabindex="-1">å–æ¶ˆç¼–è¾‘</button>
			</div>
			
			<!-- ç¡®è®¤å¯¹è¯æ¡†ï¼ˆå†…è”ï¼Œéæ¨¡æ€ï¼‰ -->
			<div id="confirmation-dialog" class="confirmation-dialog hidden" role="alertdialog" aria-labelledby="confirmation-message" aria-describedby="confirmation-description" aria-modal="false">
				<div class="confirmation-content">
					<p id="confirmation-message">ç¡®è®¤è¦æ”¾å¼ƒæœªä¿å­˜çš„æ›´æ”¹å—ï¼Ÿ</p>
					<p id="confirmation-description" class="sr-only">æ­¤æ“ä½œå°†ä¸¢å¤±æ‰€æœ‰æœªä¿å­˜çš„æ›´æ”¹å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼</p>
					<div class="confirmation-buttons" role="group" aria-label="ç¡®è®¤å¯¹è¯æ¡†æŒ‰é’®">
						<button id="confirm-btn" class="primary" role="button" aria-label="ç¡®è®¤æ”¾å¼ƒæ›´æ”¹" tabindex="0">ç¡®è®¤</button>
						<button id="cancel-confirm-btn" class="secondary" role="button" aria-label="å–æ¶ˆå¹¶ç»§ç»­ç¼–è¾‘" tabindex="0">å–æ¶ˆ</button>
					</div>
				</div>
			</div>
			
			<!-- IFC Properties Section -->
			<div class="ifc-properties-section" role="region" aria-label="IFCå±æ€§ç®¡ç†">
				<h3 id="ifc-properties-heading">IFCå±æ€§</h3>
				<div class="ifc-controls" role="group" aria-labelledby="ifc-properties-heading">
					<div class="search-box">
						<input type="text" id="property-search" placeholder="Search properties..." 
							aria-label="æœç´¢IFCå±æ€§" aria-describedby="property-search-description" tabindex="0" />
						<div id="property-search-description" class="sr-only">è¾“å…¥å…³é”®è¯æœç´¢IFCå±æ€§</div>
					</div>
					<button id="refresh-btn" title="Refresh properties" role="button" aria-label="åˆ·æ–°IFCå±æ€§" tabindex="0">
						â†» Refresh
					</button>
					<button id="view-ifc-properties-btn" role="button" aria-label="æŸ¥çœ‹æ„ä»¶çš„IFCå±æ€§" tabindex="0">æŸ¥çœ‹æ„ä»¶çš„IFCå±æ€§</button>
				</div>

				<div id="loading-state" class="loading-state hidden" role="status" aria-live="polite" aria-busy="true">
					<h3>Loading IFC properties...</h3>
					<p>Please wait while fetching property data.</p>
				</div>

				<div id="empty-state" class="empty-state hidden" role="status" aria-live="polite">
					<h3>No element selected</h3>
					<p>Select an element in Archicad to view its IFC properties.</p>
				</div>
				
				<div id="no-match-state" class="empty-state hidden" role="status" aria-live="polite">
					<h3>No matching properties</h3>
					<p>Try adjusting your search to find what you're looking for.</p>
				</div>
				
				<div id="error-state" class="error-notice hidden" role="alert" aria-live="assertive">
					<h3>Error loading IFC properties</h3>
					<p id="error-message">An unexpected error occurred while fetching IFC properties.</p>
					<button id="retry-btn" class="secondary" style="margin-top: var(--spacing-sm);" role="button" aria-label="é‡è¯•åŠ è½½IFCå±æ€§" tabindex="0">Retry</button>
				</div>

				<div id="property-groups" class="property-groups" role="region" aria-label="IFCå±æ€§åˆ†ç»„åˆ—è¡¨" aria-live="polite">
					<!-- Property groups will be inserted here by JavaScript -->
				</div>
			</div>
		</div>
	</div>

	<!-- å±å¹•é˜…è¯»å™¨å…¬å‘ŠåŒºåŸŸ -->
	<div id="screen-reader-announcements" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>
	
	<!-- JavaScriptæ¡¥æ¥çŠ¶æ€æ˜¾ç¤º -->
	<div style="font-size: var(--font-size-xs); color: var(--text-secondary); text-align: center; margin-top: var(--spacing-md); padding-top: var(--spacing-sm); border-top: 1px solid var(--border);" role="status" aria-live="polite">
		<span id="bridge-status" style="color: #ef4444;">(æ¡¥æ¥æ£€æµ‹ä¸­...)</span>
		<span id="version-status" style="margin-left: 10px;"></span>
		<button id="retry-bridge-btn" style="margin-left: 10px; padding: 2px 8px; font-size: var(--font-size-xxs); display: none;">é‡è¯•æ¡¥æ¥</button>
		<div id="bridge-debug" style="font-size: var(--font-size-xxs); margin-top: 4px; color: #888;"></div>
	</div>

	<script type="text/javascript">
		// Mock data for demonstration
		const mockPropertyData = {
			guid: "{335B0B7A-1234-5678-ABCD-EF0123456789}",
			type: "IfcWall",
			elementId: "1001",
			properties: [
				{
					schema: "IFC4",
					category: "General",
					name: "Name",
					value: "Interior Wall 001",
					type: "IfcLabel",
					unit: null
				},
				{
					schema: "IFC4",
					category: "General",
					name: "Description",
					value: "Load bearing wall with fire rating",
					type: "IfcText",
					unit: null
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Length",
					value: "5000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Height",
					value: "3000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Material",
					value: "Concrete",
					type: "IfcMaterial",
					unit: null
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Thickness",
					value: "200.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Performance",
					name: "Fire Rating",
					value: "120",
					type: "IfcTimeMeasure",
					unit: "minutes"
				}
			]
		};

		const DEBUG = true; // Enable debug logging
		function debugLog(...args) {
			if (DEBUG) {
				console.log('[HBIM Debug]', ...args);
				// Also output to debug element if available
				const debugEl = document.getElementById('debug-output');
				if (debugEl) {
					debugEl.textContent += args.join(' ') + '\n';
				}
			}
		}
		let currentProperties = []; // Holds properties for currently selected element, initially empty
		let debugInfo = {}; // Store debug information for display
		let isEditMode = false;
		let currentElementGuid = null; // GUID of currently selected element for ComponentInfo operations
		let previousElementGuid = null; // Track previous element GUID to detect changes
		let currentPhotoPaths = []; // Photo paths for currently selected element
		let hasUnsavedChanges = false; // Track unsaved changes in ComponentInfo
		let currentPhotoIndex = 0;
		let currentGlobalId = null; // GlobalId property value (required for photo functionality)
		let currentFolderName = null; // Folder name for photos based on GlobalId


		// Three-state CSS class management
		function updateUIState() {
			const body = document.body;
			const hasSelection = currentElementGuid !== null;
			const hasInfo = hasComponentInfo();
			
			debugLog('updateUIState:', {
				hasSelection,
				hasInfo,
				currentElementGuid,
				currentComponentId: document.getElementById('component-id').value,
				currentPhotoPathsLength: currentPhotoPaths.length
			});
			
			// Remove all state classes
			body.classList.remove('state-no-selection', 'state-no-info', 'state-has-info');
			
			let stateText = 'æœªçŸ¥';
			if (!hasSelection) {
				body.classList.add('state-no-selection');
				debugLog('UI State: state-no-selection');
				stateText = 'æœªé€‰æ‹©æ„ä»¶';
			} else if (!hasInfo) {
				body.classList.add('state-no-info');
				debugLog('UI State: state-no-info');
				stateText = 'å·²é€‰æ‹©æ„ä»¶æ— ä¿¡æ¯';
			} else {
				body.classList.add('state-has-info');
				debugLog('UI State: state-has-info');
				stateText = 'å·²é€‰æ‹©æ„ä»¶æœ‰ä¿¡æ¯';
			}
			
			// Update UI state indicator
			const stateIndicator = document.getElementById('ui-state-text');
			if (stateIndicator) {
				stateIndicator.textContent = stateText;
			}
			
			// Announce state change to screen readers
			let announcement = '';
			if (!hasSelection) {
				announcement = 'æœªé€‰æ‹©æ„ä»¶ã€‚è¯·å…ˆåœ¨ArchiCADä¸­é€‰æ‹©ä¸€ä¸ªæ„ä»¶ã€‚';
			} else if (!hasInfo) {
				announcement = 'å·²é€‰æ‹©æ„ä»¶ï¼Œä½†æœªå¡«å†™æ„ä»¶ä¿¡æ¯ã€‚è¯·ç‚¹å‡»"æ·»åŠ ä¿¡æ¯"æŒ‰é’®æˆ–"ç¼–è¾‘ä¿¡æ¯"æŒ‰é’®æ¥å¡«å†™æ„ä»¶ç¼–å·å’Œç…§ç‰‡æè¿°ã€‚';
			} else {
				announcement = 'å·²é€‰æ‹©æ„ä»¶å¹¶å·²å¡«å†™æ„ä»¶ä¿¡æ¯ã€‚å¯ä»¥æŸ¥çœ‹æˆ–ç¼–è¾‘æ„ä»¶ä¿¡æ¯ã€‚';
			}
			
			// Add element details if available
			if (hasSelection) {
				const guid = document.getElementById('summary-guid').textContent;
				const type = document.getElementById('summary-type').textContent;
				if (guid && guid !== '{GUID}' && type && type !== '{Element Type}') {
					announcement += ` å½“å‰æ„ä»¶ç±»å‹: ${type}ã€‚`;
				}
			}
			
			announceToScreenReader(announcement);
		}
		
		function hasComponentInfo() {
			const componentId = document.getElementById('component-id').value.trim();
			const photoDescription = document.getElementById('photo-description').value.trim();
			return componentId !== '' || photoDescription !== '' || currentPhotoPaths.length > 0;
		}
		
		function updateUnsavedIndicator() {
			const indicator = document.getElementById('componentinfo-unsaved-indicator');
			if (indicator) {
				if (hasUnsavedChanges) {
					indicator.classList.remove('hidden');
					// Announce unsaved changes to screen readers
					announceToScreenReader('æœ‰æœªä¿å­˜çš„æ›´æ”¹ã€‚è¯·ä¿å­˜æˆ–å–æ¶ˆç¼–è¾‘ã€‚');
				} else {
					indicator.classList.add('hidden');
				}
			}
		}
		
		// Update photo button disabled state and tooltip based on GlobalId availability
		function updatePhotoButtonState() {
			const button = document.getElementById('select-photos-btn');
			if (!button) return;
			
			const hasGlobalId = currentGlobalId !== null && currentGlobalId !== '';
			const isDisabled = !hasGlobalId;
			button.disabled = isDisabled;
			
			// Update tabindex based on disabled state for keyboard navigation
			button.tabIndex = isDisabled ? -1 : 0;
			
			// Set tooltip to explain why button is disabled (guardrail compliance: no fallback to GUID)
			const tooltipEl = document.getElementById('select-photos-tooltip');
			if (isDisabled) {
				button.title = 'æ­¤åŠŸèƒ½éœ€è¦æ„ä»¶å…·æœ‰GlobalIdå±æ€§ï¼ˆIFCå…¼å®¹æ„ä»¶ï¼‰';
				button.setAttribute('aria-disabled', 'true');
				if (tooltipEl) {
					tooltipEl.textContent = 'æ­¤åŠŸèƒ½éœ€è¦æ„ä»¶å…·æœ‰GlobalIdå±æ€§ï¼ˆIFCå…¼å®¹æ„ä»¶ï¼‰';
				}
			} else {
				button.title = ''; // Clear tooltip when enabled
				button.setAttribute('aria-disabled', 'false');
				if (tooltipEl) {
					tooltipEl.textContent = '';
				}
			}
		}
		
		// Update view photo button disabled state and tooltip based on GlobalId and photo availability
		function updateViewPhotoButtonState() {
			const button = document.getElementById('view-photos-btn');
			if (!button) return;
			
			const hasGlobalId = currentGlobalId !== null && currentGlobalId !== '';
			const hasPhotos = currentPhotoPaths.length > 0;
			const isDisabled = !hasGlobalId || !hasPhotos;
			button.disabled = isDisabled;
			
			// Update tabindex based on disabled state for keyboard navigation
			button.tabIndex = isDisabled ? -1 : 0;
			
			// Set tooltip to explain why button is disabled
			const tooltipEl = document.getElementById('view-photos-tooltip');
			if (isDisabled) {
				let tooltipText = '';
				if (!hasGlobalId) {
					tooltipText = 'æ­¤åŠŸèƒ½éœ€è¦æ„ä»¶å…·æœ‰GlobalIdå±æ€§ï¼ˆIFCå…¼å®¹æ„ä»¶ï¼‰';
				} else if (!hasPhotos) {
					tooltipText = 'æ­¤æ„ä»¶æš‚æ— ç…§ç‰‡ï¼Œè¯·å…ˆé€‰æ‹©ç…§ç‰‡';
				} else {
					tooltipText = ''; // Should not happen
				}
				button.title = tooltipText;
				button.setAttribute('aria-disabled', 'true');
				if (tooltipEl) {
					tooltipEl.textContent = tooltipText;
				}
			} else {
				button.title = ''; // Clear tooltip when enabled
				button.setAttribute('aria-disabled', 'false');
				if (tooltipEl) {
					tooltipEl.textContent = '';
				}
			}
		}

		// Update GlobalId status indicator for photo functionality discoverability
		function updateGlobalIdStatusIndicator() {
			const statusEl = document.getElementById('global-id-status');
			if (!statusEl) return;
			
			const hasGlobalId = currentGlobalId !== null && currentGlobalId !== '';
			if (hasGlobalId) {
				statusEl.textContent = 'GlobalId: å·²å…·å¤‡ (ç…§ç‰‡åŠŸèƒ½å¯ç”¨)';
				statusEl.className = 'status-indicator has-global-id';
			} else {
				statusEl.textContent = 'GlobalId: ç¼ºå¤± (ç…§ç‰‡åŠŸèƒ½ä¸å¯ç”¨)';
				statusEl.className = 'status-indicator no-global-id';
			}
		}

		// Keyboard shortcuts for edit mode
		function setupEditModeKeyboardShortcuts() {
			document.addEventListener('keydown', handleEditModeKeydown);
		}
		
		function removeEditModeKeyboardShortcuts() {
			document.removeEventListener('keydown', handleEditModeKeydown);
		}
		
		function handleEditModeKeydown(e) {
			// Only handle if we're in edit mode
			if (!isEditMode) return;
			
			// Ctrl+S or Cmd+S: save
			if ((e.ctrlKey || e.metaKey) && e.key === 's') {
				e.preventDefault(); // Prevent browser save dialog
				// Trigger save if save button is visible and enabled
				const saveBtn = document.getElementById('save-info-btn');
				if (saveBtn && !saveBtn.classList.contains('hidden')) {
					saveBtn.click();
				}
				return;
			}
			
			// Escape: cancel edit mode (if no unsaved changes) or show confirmation
			if (e.key === 'Escape') {
				// Don't handle Escape if confirmation dialog is visible (let dialog handle it)
				const confirmationDialog = document.getElementById('confirmation-dialog');
				if (confirmationDialog && !confirmationDialog.classList.contains('hidden')) {
					return;
				}
				e.preventDefault();
				// If there are unsaved changes, show confirmation dialog
				if (hasUnsavedChanges) {
					showConfirmation(
						'æœ‰æœªä¿å­˜çš„æ›´æ”¹ã€‚ç¡®è®¤è¦æ”¾å¼ƒæ›´æ”¹å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼å—ï¼Ÿ',
						function() { exitEditMode(false); }, // User confirmed
						function() { console.log('ç”¨æˆ·å–æ¶ˆé€€å‡ºç¼–è¾‘æ¨¡å¼'); } // User cancelled
					);
				} else {
					exitEditMode(false);
				}
				return;
			}
		}
		
		// Tab switching functionality - REMOVED since we don't have tabs anymore
		// function switchTab(tabId) {
		// 	// Hide all tab contents
		// 	document.querySelectorAll('.tab-content').forEach(content => {
		// 		content.classList.remove('active');
		// 	});
		// 	
		// 	// Deactivate all tab buttons
		// 	document.querySelectorAll('.tab-button').forEach(button => {
		// 		button.classList.remove('active');
		// 	});
		// 	
		// 	// Activate selected tab
		// 	document.getElementById(tabId + '-content').classList.add('active');
		// 	document.getElementById(tabId + '-tab').classList.add('active');
		// }
		
		// Transform C++ property array format to UI property object format
		// C++ format: [propertySetName, propertyName, propertyValue, propertyType, unit, isValid]
		// UI format: {schema, category, name, value, type, unit}
		function transformCppPropertiesToUI(cppProperties) {
			console.log('transformCppPropertiesToUI called with:', cppProperties);
			if (!cppProperties) {
				console.warn('cppProperties is null or undefined');
				return [];
			}
			if (!Array.isArray(cppProperties)) {
				console.warn('cppProperties is not an array:', typeof cppProperties, cppProperties);
				return [];
			}
			console.log(`Received ${cppProperties.length} properties from C++ backend`);
			const uiProperties = [];
			for (let i = 0; i < cppProperties.length; i++) {
				const prop = cppProperties[i];
				if (!Array.isArray(prop) || prop.length < 6) {
					console.warn(`Property at index ${i} is invalid:`, prop);
					continue;
				}
				const [propertySetName, propertyName, propertyValue, propertyType, unit, isValid] = prop;
				// Filter out invalid properties
				if (isValid === false) {
					console.log(`Property ${propertySetName}.${propertyName} is invalid (isValid=false), skipping`);
					continue;
				}
				// Map propertySetName -> category
				// For schema, we can try to extract IFC version from propertySetName, default to "IFC"
				let schema = "IFC";
				const schemaMatch = propertySetName.match(/IFC(2X3|4|2x3)?/i);
				if (schemaMatch) schema = schemaMatch[0].toUpperCase();
				uiProperties.push({
					schema: schema,
					category: propertySetName,
					name: propertyName,
					value: propertyValue,
					type: propertyType,
					unit: unit || null
				});
				// Log DEBUG_INFO properties
				if (propertySetName === 'DEBUG_INFO') {
					console.log(`DEBUG_INFO: ${propertyName} = ${propertyValue}`);
				}
			}
			console.log(`Transformed to ${uiProperties.length} UI properties`);
			return uiProperties;
		}
		
		// Group properties by category (propertySetName)
		function groupProperties(properties) {
			const groups = {};
			properties.forEach(prop => {
				const key = prop.category; // propertySetName
				if (!groups[key]) {
					groups[key] = {
						schema: prop.schema,
						category: prop.category,
						properties: []
					};
				}
				groups[key].properties.push(prop);
			});
			return Object.values(groups);
		}

		// Render property groups
		function renderPropertyGroups(groups) {
			const container = document.getElementById('property-groups');
			container.innerHTML = '';

			if (groups.length === 0) {
				// Check if we have an element selected (empty-state hidden)
				const emptyState = document.getElementById('empty-state');
				if (emptyState.classList.contains('hidden')) {
					// Element is selected but no properties match filter
					document.getElementById('no-match-state').classList.remove('hidden');
				} else {
					// No element selected
					emptyState.classList.remove('hidden');
				}
				return;
			} else {
				// Hide both empty and no-match states
				document.getElementById('empty-state').classList.add('hidden');
				document.getElementById('no-match-state').classList.add('hidden');
			}

			// Lazy rendering: render groups in batches for better performance
			const batchSize = 3; // Render 3 groups per frame
			let currentIndex = 0;
			
			function renderNextBatch() {
				const batch = groups.slice(currentIndex, currentIndex + batchSize);
				currentIndex += batchSize;
				
				batch.forEach(group => {
					const groupElement = document.createElement('div');
					groupElement.className = 'group expanded';
 					const groupId = `group-${group.category.replace(/\s+/g, '-').toLowerCase()}`;
					const contentId = `${groupId}-content`;
					groupElement.innerHTML = `
						<div class="group-header" onclick="toggleGroup(this.parentElement)" onkeydown="handleGroupHeaderKeydown(event, this.parentElement)" role="button" aria-expanded="true" aria-controls="${contentId}" tabindex="0">
							<h3 id="${groupId}-heading">${group.category}</h3>
							<span class="group-badge" aria-label="${group.properties.length} ä¸ªå±æ€§">${group.properties.length}</span>
						</div>
						<div id="${contentId}" class="group-content" role="region" aria-labelledby="${groupId}-heading">
							<table class="property-table" role="grid" aria-label="${group.category} å±æ€§è¡¨">
								<thead>
									<tr role="row">
										<th role="columnheader" scope="col">Property Name</th>
										<th role="columnheader" scope="col">Value</th>
										<th role="columnheader" scope="col">Type</th>
										<th role="columnheader" scope="col">Unit</th>
									</tr>
								</thead>
								<tbody>
									${group.properties.map((prop, index) => `
										<tr role="row">
											<td class="property-name" role="rowheader" scope="row">${prop.name}</td>
											<td class="property-value" role="gridcell">${prop.value}</td>
											<td class="property-type" role="gridcell">${prop.type}</td>
											<td class="property-unit" role="gridcell">${prop.unit || 'â€”'}</td>
										</tr>
									`).join('')}
								</tbody>
							</table>
						</div>
					`;
					container.appendChild(groupElement);
				});
				
				// If there are more groups to render, schedule next batch
				if (currentIndex < groups.length) {
					requestAnimationFrame(renderNextBatch);
				}
			}
			
			// Start rendering
			requestAnimationFrame(renderNextBatch);
		}

		// Toggle group expansion
		function toggleGroup(groupElement) {
			const isExpanded = groupElement.classList.toggle('expanded');
			const header = groupElement.querySelector('.group-header');
			if (header) {
				header.setAttribute('aria-expanded', isExpanded.toString());
			}
			
			// Announce expansion state to screen readers
			const heading = groupElement.querySelector('h3');
			if (heading) {
				const groupName = heading.textContent;
				const announcement = isExpanded ? 
					`${groupName} å±æ€§ç»„å·²å±•å¼€` : 
					`${groupName} å±æ€§ç»„å·²æŠ˜å `;
				announceToScreenReader(announcement);
			}
		}
		
		// Handle keyboard events for group headers
		function handleGroupHeaderKeydown(event, groupElement) {
			// Support Enter and Space keys for toggling
			if (event.key === 'Enter' || event.key === ' ') {
				event.preventDefault(); // Prevent space from scrolling
				toggleGroup(groupElement);
			}
		}

		// Filter properties based on search input
		function filterProperties(searchTerm) {
			const filtered = currentProperties.filter(prop => 
				prop.name.toLowerCase().includes(searchTerm) ||
				prop.value.toLowerCase().includes(searchTerm) ||
				prop.type.toLowerCase().includes(searchTerm) ||
				prop.category.toLowerCase().includes(searchTerm)
			);
			const groups = groupProperties(filtered);
			renderPropertyGroups(groups);
		}

		// Update summary from selected element
		function updateElementSummary(guid, type, elementId) {
			document.getElementById('summary-guid').textContent = guid;
			document.getElementById('summary-type').textContent = type;
			// Note: summary-id element doesn't exist in new layout, removed
		}

		// Show loading state
		function showLoading() {
			document.getElementById('loading-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('error-state').classList.add('hidden');
		}

		// Hide loading state
		function hideLoading() {
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('property-groups').classList.remove('hidden');
		}

		// Show error state
		function showError(errorMessage) {
			document.getElementById('error-message').textContent = errorMessage || 'An unexpected error occurred while fetching IFC properties.';
			document.getElementById('error-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('no-match-state').classList.add('hidden');
		}

		// Main function to load and display properties
		function loadIFCProperties(elementInfos) {
			console.log('loadIFCProperties called with elementInfos:', elementInfos);
			showLoading();

			// Simulate API delay (keep for fallback)
			setTimeout(() => {
				if (!elementInfos || elementInfos.length === 0) {
					document.getElementById('empty-state').classList.remove('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					document.getElementById('property-groups').classList.add('hidden');
					updateElementSummary('â€”', 'â€”', 'â€”');
					currentProperties = [];
					// Hide multi-selection warning (if it exists)
					const warning = document.getElementById('multi-selection-warning');
					if (warning) warning.classList.add('hidden');
					hideLoading();
					return;
				}
				
				// Show/hide multi-selection warning (if it exists)
				const warning = document.getElementById('multi-selection-warning');
				if (warning && elementInfos.length > 1) {
					warning.classList.remove('hidden');
				} else if (warning) {
					warning.classList.add('hidden');
				}
				
				// Use first selected element
				const elem = elementInfos[0];
				const elementGuid = elem[0];
				updateElementSummary(elem[0], elem[1], elem[2]);
				
				// Try to fetch real IFC properties from C++ backend
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetAllIFCProperties === 'function') {
					console.log('ACAPI.GetAllIFCProperties available, calling with elementGuid:', elementGuid);
					ACAPI.GetAllIFCProperties(elementGuid)
						.then(cppProperties => {
							console.log('ACAPI.GetAllIFCProperties returned:', cppProperties);
							// Transform C++ property format to UI format
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							console.log('After transformation:', uiProperties.length, 'UI properties');
							if (uiProperties.length === 0) {
								// If no properties returned, fall back to mock data for testing
								console.warn('No IFC properties returned from backend, using mock data for demonstration');
								console.warn('Raw C++ properties that were received:', cppProperties);
								currentProperties = mockPropertyData.properties;
							} else {
								console.log('Using real IFC properties from backend');
								currentProperties = uiProperties;
							}
							
							const groups = groupProperties(currentProperties);
							console.log('Grouped into', groups.length, 'groups');
							renderPropertyGroups(groups);
							document.getElementById('empty-state').classList.add('hidden');
							document.getElementById('no-match-state').classList.add('hidden');
							hideLoading();
						})
						.catch(error => {
							console.error('Failed to fetch IFC properties:', error);
							// Show error to user
							showError(`Failed to fetch IFC properties: ${error.message || error}`);
							hideLoading();
						});
				} else {
					// ACAPI not available, use mock data (for testing outside Archicad)
					console.warn('ACAPI not available, using mock data for demonstration');
					currentProperties = mockPropertyData.properties;
					
					const groups = groupProperties(currentProperties);
					renderPropertyGroups(groups);
					document.getElementById('empty-state').classList.add('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					hideLoading();
				}
			}, 300);
		}
		
		// Update plugin version display
		function updatePluginVersion() {
			const versionElement = document.getElementById('version-display');
			if (!versionElement) return;
			
			// Guardrail compliance: No caching system (removed ClearIFCPropertyCache)
			
			// Get plugin version
			if (typeof ACAPI !== 'undefined' && ACAPI.GetPluginVersion) {
				ACAPI.GetPluginVersion().then(version => {
					console.log('Plugin version from C++:', version);
					versionElement.textContent = `HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…· (V${version})`;
				}).catch(error => {
					console.warn('Failed to get plugin version:', error);
					versionElement.textContent = 'HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…· (V0.0.0.0)';
				});
			} else {
				// ACAPI not available, use default
				versionElement.textContent = 'HBIMæ„ä»¶ä¿¡æ¯è¾“å…¥å·¥å…· (V0.0.0.0)';
			}
		}
		
		// ComponentInfo edit mode functions
		
		// Inline confirmation dialog function (non-modal, guardrail compliant)
		function showConfirmation(message, onConfirm, onCancel) {
			const dialog = document.getElementById('confirmation-dialog');
			const messageEl = document.getElementById('confirmation-message');
			const confirmBtn = document.getElementById('confirm-btn');
			const cancelBtn = document.getElementById('cancel-confirm-btn');
			
			if (!dialog || !messageEl || !confirmBtn || !cancelBtn) {
				console.error('Confirmation dialog elements not found');
				// Fallback to immediate confirm
				if (window.confirm(message)) {
					onConfirm && onConfirm();
				} else {
					onCancel && onCancel();
				}
				return;
			}
			
			// Set message
			messageEl.textContent = message;
			
			// Show dialog
			dialog.classList.remove('hidden');
			
			// Define cleanup function
			function cleanup() {
				document.removeEventListener('keydown', handleKeydown);
				confirmBtn.removeEventListener('click', handleConfirm);
				cancelBtn.removeEventListener('click', handleCancel);
			}
			
			// Handle confirm button click
			function handleConfirm() {
				cleanup();
				dialog.classList.add('hidden');
				onConfirm && onConfirm();
			}
			
			// Handle cancel button click
			function handleCancel() {
				cleanup();
				dialog.classList.add('hidden');
				onCancel && onCancel();
			}
			
			// Handle escape key
			function handleKeydown(e) {
				if (e.key === 'Escape') {
					e.preventDefault();
					handleCancel();
				}
			}
			
			// Add event listeners
			confirmBtn.addEventListener('click', handleConfirm);
			cancelBtn.addEventListener('click', handleCancel);
			document.addEventListener('keydown', handleKeydown);
		}
		
		// Focus management functions for accessibility
		function manageFocusOnEditModeEnter() {
			// When entering edit mode, focus should go to the first editable field
			const componentIdInput = document.getElementById('component-id');
			if (componentIdInput) {
				componentIdInput.focus();
				componentIdInput.select(); // Select all text for easy editing
			}
			
			// Update tabindex for edit mode
			document.getElementById('component-id').tabIndex = 0;
			document.getElementById('photo-description').tabIndex = 0;
			document.getElementById('save-info-btn').tabIndex = 0;
			document.getElementById('cancel-edit-btn').tabIndex = 0;
			document.getElementById('select-photos-btn').tabIndex = 0;
			document.getElementById('view-photos-btn').tabIndex = 0;
			document.getElementById('edit-info-btn').tabIndex = -1;
			document.getElementById('prev-photo-btn').tabIndex = 0;
			document.getElementById('next-photo-btn').tabIndex = 0;
			
			// Update ARIA attributes for edit mode
			document.getElementById('component-id').setAttribute('aria-readonly', 'false');
			document.getElementById('photo-description').setAttribute('aria-readonly', 'false');
			document.getElementById('component-id').removeAttribute('aria-disabled');
			document.getElementById('photo-description').removeAttribute('aria-disabled');
			
			// Announce edit mode to screen readers
			announceToScreenReader('å·²è¿›å…¥ç¼–è¾‘æ¨¡å¼ã€‚è¯·å¡«å†™æ„ä»¶ç¼–å·å’Œç…§ç‰‡æè¿°ä¿¡æ¯ã€‚');
		}
		
		function manageFocusOnEditModeExit() {
			// When exiting edit mode, focus should return to the edit button
			const editButton = document.getElementById('edit-info-btn');
			if (editButton) {
				editButton.focus();
			}
			
			// Update tabindex for view mode
			document.getElementById('component-id').tabIndex = -1;
			document.getElementById('photo-description').tabIndex = -1;
			document.getElementById('save-info-btn').tabIndex = -1;
			document.getElementById('cancel-edit-btn').tabIndex = -1;
			document.getElementById('select-photos-btn').tabIndex = 0;
			document.getElementById('view-photos-btn').tabIndex = 0;
			document.getElementById('edit-info-btn').tabIndex = 0;
			document.getElementById('prev-photo-btn').tabIndex = -1;
			document.getElementById('next-photo-btn').tabIndex = -1;
			
			// Update ARIA attributes for view mode
			document.getElementById('component-id').setAttribute('aria-readonly', 'true');
			document.getElementById('photo-description').setAttribute('aria-readonly', 'true');
			document.getElementById('component-id').setAttribute('aria-disabled', 'true');
			document.getElementById('photo-description').setAttribute('aria-disabled', 'true');
			
			// Announce exit from edit mode to screen readers
			announceToScreenReader('å·²é€€å‡ºç¼–è¾‘æ¨¡å¼ã€‚æ„ä»¶ä¿¡æ¯å·²ä¿å­˜ã€‚');
		}
		
		function announceToScreenReader(message) {
			const announcementEl = document.getElementById('screen-reader-announcements');
			if (announcementEl) {
				announcementEl.textContent = message;
				// Clear after a short delay to allow repeated announcements
				setTimeout(() => {
					announcementEl.textContent = '';
				}, 1000);
			}
		}
		
 		function enterEditMode() {
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('è¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼ŒcurrentElementGuid: ' + currentElementGuid);
			} else {
				console.log('è¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼ŒcurrentElementGuid:', currentElementGuid);
			}
			isEditMode = true;
			setupEditModeKeyboardShortcuts();
			hasUnsavedChanges = false;
			updateUnsavedIndicator();
			document.getElementById('component-id').disabled = false;
			document.getElementById('photo-description').disabled = false;
			// Update photo button state based on GlobalId availability
			updatePhotoButtonState();
			// Hide edit button, show save and cancel buttons
			document.getElementById('edit-info-btn').classList.add('hidden');
			document.getElementById('save-info-btn').classList.remove('hidden');
			document.getElementById('cancel-edit-btn').classList.remove('hidden');
			document.getElementById('view-ifc-properties-btn').disabled = true;
			// Show edit mode buttons container
			const editModeButtons = document.querySelector('.edit-mode-buttons');
			if (editModeButtons) {
				editModeButtons.classList.remove('hidden');
			}
			// Show edit mode notification
			const notification = document.getElementById('edit-mode-notification');
			if (notification) {
				notification.classList.remove('hidden');
			}
			// Notify C++ backend about edit mode change
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_SetEditMode === 'function') {
				ACAPI.ComponentInfo_SetEditMode('true').catch(err => console.warn('Failed to set edit mode:', err));
			}
			
 			// Update UI state
			updateUIState();
			
			// Manage focus for accessibility
			setTimeout(() => {
				manageFocusOnEditModeEnter();
			}, 100);
		}

		/* Help text for photo functionality */
		.help-text {
			font-size: var(--font-size-xs);
			color: var(--text-secondary);
			margin-bottom: var(--spacing-sm);
			line-height: 1.3;
		}

		.status-indicator {
			display: inline-block;
			padding: 2px 6px;
			border-radius: 3px;
			font-size: var(--font-size-xs);
			font-weight: 500;
		}

		.status-indicator.has-global-id {
			background-color: rgba(16, 185, 129, 0.1);
			color: var(--success);
		}

		.status-indicator.no-global-id {
			background-color: rgba(239, 68, 68, 0.1);
			color: var(--error);
		}
		
		function showPhotoAtIndex(index) {
			const photoDisplay = document.getElementById('photo-display');
			const photoPlaceholder = document.querySelector('.photo-preview-placeholder');
			const prevBtn = document.getElementById('prev-photo-btn');
			const nextBtn = document.getElementById('next-photo-btn');
			const photoIndex = document.getElementById('photo-index');
			const photoNav = document.querySelector('.photo-navigation');
			
			if (!currentPhotoPaths || currentPhotoPaths.length === 0) {
				// No photos - show placeholder
				photoDisplay.classList.add('hidden');
				photoPlaceholder.classList.remove('hidden');
				photoPlaceholder.textContent = 'æœªé€‰æ‹©ç…§ç‰‡';
				photoNav.classList.add('hidden');
				return;
			}
			
			// Validate index
			if (index < 0) index = 0;
			if (index >= currentPhotoPaths.length) index = currentPhotoPaths.length - 1;
			currentPhotoIndex = index;
			
			// Update navigation buttons
			const isPrevDisabled = (currentPhotoIndex === 0);
			const isNextDisabled = (currentPhotoIndex === currentPhotoPaths.length - 1);
			
			prevBtn.disabled = isPrevDisabled;
			nextBtn.disabled = isNextDisabled;
			
			// Update tabindex and aria-disabled for accessibility
			prevBtn.tabIndex = isPrevDisabled ? -1 : 0;
			nextBtn.tabIndex = isNextDisabled ? -1 : 0;
			prevBtn.setAttribute('aria-disabled', isPrevDisabled.toString());
			nextBtn.setAttribute('aria-disabled', isNextDisabled.toString());
			
			// Update index display
			photoIndex.textContent = `${currentPhotoIndex + 1} / ${currentPhotoPaths.length}`;
			
			// Show photo - convert relative path to full path
			const photoPath = currentPhotoPaths[currentPhotoIndex];
			
			// å›¾ç‰‡åŠ è½½è¾…åŠ©å‡½æ•° - æ·»åŠ è¯¦ç»†çš„é”™è¯¯å¤„ç†
			function loadPhotoWithErrorHandling(imgElement, pathToLoad, description) {
				// æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
				imgElement.onerror = null;
				imgElement.onload = null;
				
				// è·å–è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºå…ƒç´ 
				const debugInfoElement = document.getElementById('photo-debug-info');
				const debugContentElement = debugInfoElement ? debugInfoElement.querySelector('.debug-content') : null;
				
				// éšè—è°ƒè¯•ä¿¡æ¯ï¼ˆæ¯æ¬¡æ–°åŠ è½½æ—¶é‡ç½®ï¼‰
				if (debugInfoElement) {
					debugInfoElement.classList.add('hidden');
				}
				
				// è®¾ç½®åŠ è½½å¤±è´¥çš„å¤„ç†
				imgElement.onerror = function() {
					// æ„å»ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ˆä¸­æ–‡ï¼‰
					const errorTime = new Date().toLocaleTimeString('zh-CN');
					const encodedPath = encodeURI(pathToLoad);
					const encodedPathComponent = encodeURIComponent(pathToLoad);
					
					const errorDetails = [
						`[${errorTime}] âŒ å›¾ç‰‡åŠ è½½å¤±è´¥: ${description}`,
						`   åŸå§‹è·¯å¾„: ${pathToLoad}`,
						`   ç¼–ç è·¯å¾„(file:///${encodedPath})`,
						`   ç¼–ç è·¯å¾„(file:///${encodedPathComponent})`,
						`   å¯èƒ½çš„åŸå› :`,
						`   1. CEFå®‰å…¨é™åˆ¶é˜»æ­¢äº†file://åè®®`,
						`   2. æ–‡ä»¶ä¸å­˜åœ¨æˆ–è·¯å¾„é”™è¯¯`,
						`   3. ä¸­æ–‡å­—ç¬¦ç¼–ç é—®é¢˜`,
						`   4. è·¨åŸŸé™åˆ¶(CORS)`,
						``,
						`   å»ºè®®è§£å†³æ–¹æ¡ˆ:`,
						`   1. ä½¿ç”¨base64ç¼–ç æ›¿ä»£file://åè®®`,
						`   2. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨: ${pathToLoad}`,
						`   3. è”ç³»æ’ä»¶å¼€å‘è€…å¯ç”¨CEFè°ƒè¯•`
					].join('\n');
					
					// åœ¨è°ƒè¯•ä¿¡æ¯åŒºåŸŸæ˜¾ç¤ºé”™è¯¯
					if (debugInfoElement && debugContentElement) {
						debugContentElement.textContent = errorDetails;
						debugInfoElement.classList.remove('hidden');
					}
					
					// åœ¨ç…§ç‰‡å ä½ç¬¦å¤„æ˜¾ç¤ºç®€è¦é”™è¯¯ä¿¡æ¯
					photoPlaceholder.classList.remove('hidden');
					photoPlaceholder.textContent = 'å›¾ç‰‡åŠ è½½å¤±è´¥ - æŸ¥çœ‹ä¸‹æ–¹è°ƒè¯•ä¿¡æ¯';
					photoPlaceholder.style.color = '#ff6b6b';
					photoDisplay.classList.add('hidden');
					photoNav.classList.remove('hidden');
					
					// å°è¯•ä½¿ç”¨encodeURIComponentå†æ¬¡åŠ è½½ï¼ˆè‡ªåŠ¨é‡è¯•ï¼‰
					setTimeout(() => {
						const retryPath = 'file:///' + encodeURIComponent(pathToLoad);
						if (debugContentElement) {
							debugContentElement.textContent += `\n\nâ³ å°è¯•é‡æ–°åŠ è½½: ${retryPath}`;
						}
						imgElement.src = retryPath;
					}, 1000);
				};
				
				// è®¾ç½®åŠ è½½æˆåŠŸçš„å¤„ç†
				imgElement.onload = function() {
					// éšè—è°ƒè¯•ä¿¡æ¯
					if (debugInfoElement) {
						debugInfoElement.classList.add('hidden');
					}
					
					// æ˜¾ç¤ºå›¾ç‰‡å¹¶éšè—å ä½ç¬¦
					photoDisplay.classList.remove('hidden');
					photoPlaceholder.classList.add('hidden');
					photoNav.classList.remove('hidden');
					
					// å¯é€‰ï¼šåœ¨è°ƒè¯•ä¿¡æ¯ä¸­æ˜¾ç¤ºæˆåŠŸä¿¡æ¯ï¼ˆä¿æŒéšè—ï¼‰
					if (debugContentElement) {
						debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] âœ… å›¾ç‰‡åŠ è½½æˆåŠŸ: ${description}\nè·¯å¾„: ${pathToLoad}`;
					}
				};
				
				// å¼€å§‹åŠ è½½å›¾ç‰‡
				imgElement.src = 'file:///' + encodeURI(pathToLoad);
				
				// æ˜¾ç¤ºåŠ è½½çŠ¶æ€
				if (debugContentElement) {
					debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] ğŸ“¸ å¼€å§‹åŠ è½½å›¾ç‰‡: ${description}\nè·¯å¾„: ${pathToLoad}`;
					debugInfoElement.classList.remove('hidden');
				}
			}
			
			function tryLoadPhotoWithBase64() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_GetPhotoBase64 === 'function' && currentElementGuid) {
					if (debugContentElement) {
						debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] ğŸ”„ å°è¯•base64ç¼–ç åŠ è½½: ${photoPath}`;
						debugInfoElement.classList.remove('hidden');
					}
					
					return ACAPI.ComponentInfo_GetPhotoBase64([currentElementGuid, photoPath])
						.then(function(base64Url) {
							if (base64Url && base64Url.length > 0 && base64Url.startsWith('data:image/')) {
								// æˆåŠŸè·å–base64æ•°æ®URL
								if (debugContentElement) {
									debugContentElement.textContent = `[${new Date().toLocaleTimeString('zh-CN')}] âœ… base64ç¼–ç æˆåŠŸ, é•¿åº¦: ${base64Url.length}`;
								}
								photoDisplay.src = base64Url;
								photoDisplay.classList.remove('hidden');
								photoPlaceholder.classList.add('hidden');
								photoNav.classList.remove('hidden');
								
								// è®¾ç½®æˆåŠŸå¤„ç†
								photoDisplay.onload = function() {
									if (debugInfoElement) {
										debugInfoElement.classList.add('hidden');
									}
								};
								
								// è®¾ç½®å¤±è´¥å¤„ç†
								photoDisplay.onerror = function() {
									if (debugContentElement) {
										debugContentElement.textContent += `\nâŒ base64æ•°æ®URLåŠ è½½å¤±è´¥ï¼Œå°è¯•file://å›é€€`;
									}
									tryLoadPhotoWithFileProtocol();
								};
								
								return true; // æˆåŠŸ
							} else {
								// base64ç¼–ç å¤±è´¥æˆ–æ— æ•ˆæ•°æ®
								if (debugContentElement) {
									debugContentElement.textContent += `\nâš ï¸ base64ç¼–ç è¿”å›æ— æ•ˆæ•°æ®ï¼Œå°è¯•file://å›é€€`;
								}
								return tryLoadPhotoWithFileProtocol();
							}
						})
						.catch(function(err) {
							if (debugContentElement) {
								debugContentElement.textContent += `\nâš ï¸ base64ç¼–ç å¤±è´¥: ${err}, å°è¯•file://å›é€€`;
							}
							return tryLoadPhotoWithFileProtocol();
						});
				} else {
					// base64 API not available
					return tryLoadPhotoWithFileProtocol();
				}
			}
			
			function tryLoadPhotoWithFileProtocol() {
				// è·å–è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºå…ƒç´ 
				const debugInfoElement = document.getElementById('photo-debug-info');
				const debugContentElement = debugInfoElement ? debugInfoElement.querySelector('.debug-content') : null;
				
				if (debugContentElement) {
					debugContentElement.textContent += `\n[${new Date().toLocaleTimeString('zh-CN')}] ğŸ”„ å°è¯•file://åè®®åŠ è½½: ${photoPath}`;
				}
				
				loadPhotoWithErrorHandling(photoDisplay, photoPath, `ç…§ç‰‡ ${currentPhotoIndex + 1}/${currentPhotoPaths.length}`);
				return false; // file:// protocol may fail due to CEF restrictions
			}
			
			// è·å–è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºå…ƒç´ 
			const debugInfoElement = document.getElementById('photo-debug-info');
			const debugContentElement = debugInfoElement ? debugInfoElement.querySelector('.debug-content') : null;
			
			// é¦–å…ˆå°è¯•base64ç¼–ç ï¼ˆå¦‚æœå¯ç”¨ï¼‰
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_GetPhotoBase64 === 'function' && currentElementGuid) {
				tryLoadPhotoWithBase64();
			} else {
				// ç›´æ¥ä½¿ç”¨file://åè®®
				tryLoadPhotoWithFileProtocol();
			}
		}
		
		function showNextPhoto() {
			if (currentPhotoPaths && currentPhotoPaths.length > 0) {
				showPhotoAtIndex(currentPhotoIndex + 1);
			}
		}
		
		function showPrevPhoto() {
			if (currentPhotoPaths && currentPhotoPaths.length > 0) {
				showPhotoAtIndex(currentPhotoIndex - 1);
			}
		}
		
		function updatePhotoPreview() {
			if (currentPhotoPaths && currentPhotoPaths.length > 0) {
				showPhotoAtIndex(currentPhotoIndex);
			} else {
				const photoDisplay = document.getElementById('photo-display');
				const photoPlaceholder = document.querySelector('.photo-preview-placeholder');
				const photoNav = document.querySelector('.photo-navigation');
				
				photoDisplay.classList.add('hidden');
				photoPlaceholder.classList.remove('hidden');
				photoPlaceholder.textContent = 'æœªé€‰æ‹©ç…§ç‰‡';
				photoNav.classList.add('hidden');
			}
		}
		
  		// Helper function to refresh component info display for current element
		function refreshComponentInfoDisplay() {
			if (currentElementGuid && !isEditMode) {
				// Only refresh if we're not in edit mode (to preserve user input)
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_GetComponentInfo === 'function') {
					ACAPI.ComponentInfo_GetComponentInfo(currentElementGuid).then(function (componentInfo) {
						if (componentInfo && Array.isArray(componentInfo) && componentInfo.length >= 3) {
							const componentId = componentInfo[0];
							const photoDescription = componentInfo[1];
							const photoPaths = componentInfo[2];
							
							document.getElementById('component-id').value = componentId || '';
							document.getElementById('photo-description').value = photoDescription || '';
							currentPhotoPaths = photoPaths || [];
							currentPhotoIndex = 0;
							updatePhotoPreview();
							updateUIState();
						}
					}).catch(function (err) {
						console.error('Failed to load component info:', err);
						// Don't clear fields on error
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('refreshComponentInfoDisplay: åŠ è½½æ„ä»¶ä¿¡æ¯å¤±è´¥ï¼Œä¿æŒå½“å‰å€¼ï¼Œé”™è¯¯: ' + err);
						}
					});
				}
			}
		}
		
		function exitEditMode(save) {
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('é€€å‡ºç¼–è¾‘æ¨¡å¼ï¼Œsave=' + save + ', currentElementGuid=' + currentElementGuid);
			} else {
				console.log('é€€å‡ºç¼–è¾‘æ¨¡å¼ï¼Œsave=', save, 'currentElementGuid=', currentElementGuid);
			}
			
			if (save && currentElementGuid) {
				const componentId = document.getElementById('component-id').value;
				const photoDescription = document.getElementById('photo-description').value;
				
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_SaveComponentInfo === 'function') {
					ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
						.then(function (success) {
							if (success) {
								console.log('Component info saved successfully');
								hasUnsavedChanges = false;
								updateUnsavedIndicator();
								// Refresh component info display to confirm save
								refreshComponentInfoDisplay();
								// Force update of selected elements to ensure all data is fresh
								setTimeout(function() {
									UpdateSelectedElements();
								}, 100);
							} else {
								console.error('Failed to save component info');
							}
						})
						.catch(function (err) {
							console.error('Error saving component info:', err);
						});
				} else {
					console.warn('ComponentInfo_SaveComponentInfo API not available');
				}
			}
			
			isEditMode = false;
			removeEditModeKeyboardShortcuts();
			hasUnsavedChanges = false;
			updateUnsavedIndicator();
			document.getElementById('component-id').disabled = true;
			document.getElementById('photo-description').disabled = true;
			// Update photo button state based on GlobalId availability
			updatePhotoButtonState();
			// Show edit button, hide save and cancel buttons
			document.getElementById('edit-info-btn').classList.remove('hidden');
			document.getElementById('save-info-btn').classList.add('hidden');
			document.getElementById('cancel-edit-btn').classList.add('hidden');
			document.getElementById('view-ifc-properties-btn').disabled = false;
			// Hide edit mode buttons container
			const editModeButtons = document.querySelector('.edit-mode-buttons');
			if (editModeButtons) {
				editModeButtons.classList.add('hidden');
			}
			// Hide edit mode notification
			const notification = document.getElementById('edit-mode-notification');
			if (notification) {
				notification.classList.add('hidden');
			}
			
			// Notify C++ backend about edit mode change
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ComponentInfo_SetEditMode === 'function') {
				ACAPI.ComponentInfo_SetEditMode('false').catch(err => console.warn('Failed to set edit mode:', err));
			}
			
 			// Refresh display to show saved values
			refreshComponentInfoDisplay();
			// Update UI state
			updateUIState();
			
			// Manage focus for accessibility
			setTimeout(() => {
				manageFocusOnEditModeExit();
			}, 100);
		}
		
		// Event listeners
		document.addEventListener('DOMContentLoaded', function() {
			// Debug: log ACAPI availability
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
				ACAPI.LogDebug('HTML loaded: Checking ACAPI availability');
			} else {
				console.log('HTML loaded: Checking ACAPI availability');
			}
			function updateBridgeStatus(isAvailable, funcs, version) {
				const statusEl = document.getElementById('bridge-status');
				const versionEl = document.getElementById('version-status');
				const debugEl = document.getElementById('bridge-debug');
				const retryBtn = document.getElementById('retry-bridge-btn');
				
				if (!statusEl) return;
				
				if (isAvailable) {
					statusEl.textContent = `(æ¡¥æ¥å°±ç»ª, ${funcs.length} ä¸ªå‡½æ•°)`;
					statusEl.style.color = '#10b981'; // success green
					if (retryBtn) retryBtn.style.display = 'none';
				} else {
					statusEl.textContent = '(æ¡¥æ¥æœªè¿æ¥)';
					statusEl.style.color = '#ef4444'; // error red
					if (retryBtn) retryBtn.style.display = 'inline-block';
				}
				
				if (version) {
					if (versionEl) {
						versionEl.textContent = `ç‰ˆæœ¬: ${version}`;
						versionEl.style.color = version === '0.0.0.0' ? '#f59e0b' : '#10b981';
					}
					if (statusEl) {
						statusEl.textContent += ` v${version}`;
					}
				} else if (versionEl) {
					versionEl.textContent = 'ç‰ˆæœ¬: æœªè·å–';
					versionEl.style.color = '#f59e0b';
				}
				
				if (debugEl && funcs) {
					debugEl.textContent = `å¯ç”¨å‡½æ•°: ${funcs.join(', ')}`;
					debugEl.style.color = funcs.length > 0 ? '#10b981' : '#ef4444';
				}
			}
			
			if (typeof ACAPI !== 'undefined') {
				// Try to log via ACAPI.LogDebug if available
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('HTML loaded: ACAPI object is defined');
				} else {
					console.log('ACAPI object is defined');
				}
				
				// List available functions
				const funcs = Object.keys(ACAPI).filter(key => typeof ACAPI[key] === 'function');
				if (typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('ACAPI functions: ' + JSON.stringify(funcs));
				} else {
					console.log('ACAPI functions:', funcs);
				}
				updateBridgeStatus(true, funcs, null);
				
				// Try to call GetPluginVersion to test bridge
				if (ACAPI.GetPluginVersion) {
					ACAPI.GetPluginVersion().then(version => {
						if (typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Plugin version from ACAPI: ' + version);
						} else {
							console.log('Plugin version from ACAPI:', version);
						}
						updateBridgeStatus(true, funcs, version);
					}).catch(err => {
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('Failed to get plugin version: ' + err);
						} else {
							console.error('Failed to get plugin version:', err);
						}
						updateBridgeStatus(true, funcs, 'error');
					});
				}
			} else {
				// ACAPI not available at all
				console.error('ACAPI object is NOT defined - JavaScript bridge not working');
				updateBridgeStatus(false, [], null);
			}
			// Initialize unsaved changes indicator
			updateUnsavedIndicator();
			
			// Initialize plugin version display
			updatePluginVersion();
			
			// Search input for IFC properties
			const searchInput = document.getElementById('property-search');
			searchInput.addEventListener('input', function(e) {
				filterProperties(e.target.value.toLowerCase());
			});

			// ComponentInfo input change tracking
			const componentIdInput = document.getElementById('component-id');
			const photoDescriptionInput = document.getElementById('photo-description');
			
			componentIdInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});
			
			photoDescriptionInput.addEventListener('input', function() {
				if (isEditMode) {
					hasUnsavedChanges = true;
					updateUnsavedIndicator();
				}
			});

			// Refresh button
			document.getElementById('refresh-btn').addEventListener('click', function() {
				// In real implementation, re-fetch properties for current selection
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});

			// Retry button for error state
			document.getElementById('retry-btn').addEventListener('click', function() {
				document.getElementById('error-state').classList.add('hidden');
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// View IFC Properties button
			document.getElementById('view-ifc-properties-btn').addEventListener('click', function() {
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
					ACAPI.GetSelectedElements().then(loadIFCProperties);
				}
			});
			
			// Edit info button
			document.getElementById('edit-info-btn').addEventListener('click', function() {
				enterEditMode();
			});
			
			// Add info button (shown when no info exists)
			document.getElementById('add-info-btn').addEventListener('click', function() {
				enterEditMode();
			});
			
			// Save info button
			document.getElementById('save-info-btn').addEventListener('click', function() {
				exitEditMode(true); // Save changes
			});
			
			// Cancel edit button
			document.getElementById('cancel-edit-btn').addEventListener('click', function() {
				// Check for unsaved changes
				if (hasUnsavedChanges) {
					showConfirmation(
						'æœ‰æœªä¿å­˜çš„æ›´æ”¹ã€‚ç¡®è®¤è¦æ”¾å¼ƒæ›´æ”¹å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼å—ï¼Ÿ',
						function() {
							// User confirmed: discard changes
							exitEditMode(false);
						},
						function() {
							// User cancelled: stay in edit mode
							console.log('ç”¨æˆ·å–æ¶ˆé€€å‡ºç¼–è¾‘æ¨¡å¼');
						}
					);
				} else {
					// No unsaved changes, exit immediately
					exitEditMode(false);
				}
			});
			
			// Select photos button
			document.getElementById('select-photos-btn').addEventListener('click', function() {
				// Debug logging
				const debugInfo = {
					currentElementGuid: currentElementGuid,
					isEditMode: isEditMode,
					ACAPI_Available: typeof ACAPI !== 'undefined',
					ComponentInfo_SelectPhotos_Available: typeof ACAPI.ComponentInfo_SelectPhotos === 'function'
				};
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
					ACAPI.LogDebug('é€‰æ‹©ç…§ç‰‡æŒ‰é’®è¢«ç‚¹å‡»: ' + JSON.stringify(debugInfo));
				} else {
					console.log('é€‰æ‹©ç…§ç‰‡æŒ‰é’®è¢«ç‚¹å‡»', debugInfo);
				}
				
				if (!currentElementGuid) {
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('é”™è¯¯: No element selected (currentElementGuid is null)');
					} else {
						console.error('No element selected');
					}
					return;
				}
				
				// Guardrail: require GlobalId for photo functionality
				if (!currentGlobalId || currentGlobalId === '') {
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('é”™è¯¯: æ„ä»¶ç¼ºå°‘GlobalIdå±æ€§ï¼Œæ— æ³•ä¿å­˜ç…§ç‰‡');
					} else {
						console.error('æ„ä»¶ç¼ºå°‘GlobalIdå±æ€§ï¼Œæ— æ³•ä¿å­˜ç…§ç‰‡');
					}
					return;
				}
				
				if (typeof ACAPI.ComponentInfo_SelectPhotos === 'function') {
					ACAPI.ComponentInfo_SelectPhotos(currentElementGuid).then(function (selectedPaths) {
						if (selectedPaths && selectedPaths.length > 0) {
							// Append new photo paths to existing ones
							currentPhotoPaths = currentPhotoPaths.concat(selectedPaths);
							hasUnsavedChanges = true;
							updateUnsavedIndicator();
							// Save immediately with updated photo paths
							const componentId = document.getElementById('component-id').value;
							const photoDescription = document.getElementById('photo-description').value;
							
							ACAPI.ComponentInfo_SaveComponentInfo([currentElementGuid, componentId, photoDescription, currentPhotoPaths])
								.then(function (success) {
									if (success) {
										console.log('Photos added and saved successfully');
										hasUnsavedChanges = false;
										updateUnsavedIndicator();
										// Enable view photos button and update preview
										updateViewPhotoButtonState();
										updatePhotoPreview();
										// Update UI state since photos were added
										updateUIState();
									} else {
										console.error('Failed to save photos');
									}
								})
								.catch(function (err) {
									console.error('Error saving photos:', err);
								});
						}
					}).catch(function (err) {
						console.error('Error selecting photos:', err);
					});
				} else {
					console.warn('ComponentInfo_SelectPhotos API not available');
				}
			});
			
			// View photos button - open current photo file
			document.getElementById('view-photos-btn').addEventListener('click', function() {
				if (!currentElementGuid) {
					console.error('No element selected');
					return;
				}
				
				// Guardrail: require GlobalId for photo functionality
				if (!currentGlobalId || currentGlobalId === '') {
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('é”™è¯¯: æ„ä»¶ç¼ºå°‘GlobalIdå±æ€§ï¼Œæ— æ³•æŸ¥çœ‹ç…§ç‰‡');
					} else {
						console.error('æ„ä»¶ç¼ºå°‘GlobalIdå±æ€§ï¼Œæ— æ³•æŸ¥çœ‹ç…§ç‰‡');
					}
					return;
				}
				
				if (currentPhotoPaths && currentPhotoPaths.length > 0) {
					if (typeof ACAPI.ComponentInfo_ViewPhotos === 'function') {
						ACAPI.ComponentInfo_ViewPhotos([currentElementGuid, currentPhotoPaths[currentPhotoIndex]]).catch(function (err) {
							console.error('Error viewing photo:', err);
						});
					} else {
						console.warn('ComponentInfo_ViewPhotos API not available');
					}
				} else {
					console.warn('No photos to view');
				}
			});
			
			// Photo navigation buttons
			document.getElementById('prev-photo-btn').addEventListener('click', showPrevPhoto);
			document.getElementById('next-photo-btn').addEventListener('click', showNextPhoto);
			
			// Initialize UI state
			updateUIState();
			updateGlobalIdStatusIndicator();
			
			// Initial load of selected elements
			UpdateSelectedElements();
			
			// Set up periodic selection update (every 250ms for faster response)
			setInterval(function() {
				UpdateSelectedElements();
			}, 250);
			
			// Retry bridge connection button
			document.getElementById('retry-bridge-btn').addEventListener('click', function() {
				console.log('Retrying bridge connection...');
				const statusEl = document.getElementById('bridge-status');
				if (statusEl) {
					statusEl.textContent = '(é‡è¯•æ¡¥æ¥ä¸­...)';
					statusEl.style.color = '#f59e0b';
				}
				
				// Force re-check ACAPI availability
				if (typeof ACAPI !== 'undefined') {
					const funcs = Object.keys(ACAPI).filter(key => typeof ACAPI[key] === 'function');
					console.log('ACAPI available, functions:', funcs);
					updateBridgeStatus(true, funcs, null);
					
					// Try to get version again
					if (ACAPI.GetPluginVersion) {
						ACAPI.GetPluginVersion().then(version => {
							console.log('Plugin version after retry:', version);
							updateBridgeStatus(true, funcs, version);
							updatePluginVersion();
						}).catch(err => {
							console.error('Failed to get plugin version after retry:', err);
							updateBridgeStatus(true, funcs, 'error');
						});
					}
				} else {
					console.log('ACAPI not available after retry');
					updateBridgeStatus(false, [], null);
				}
			});
		});
		
		// Global function to update selected elements (called from C++ when selection changes)
		function UpdateSelectedElements() {
			debugLog('UpdateSelectedElements called');
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					// Debug logging
					debugLog('GetSelectedElements returned:', elemInfos ? elemInfos.length : 0, 'elements', elemInfos);
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('UpdateSelectedElements: æ”¶åˆ° ' + (elemInfos ? elemInfos.length : 0) + ' ä¸ªå…ƒç´ ');
					} else {
						console.log('UpdateSelectedElements: Received', elemInfos ? elemInfos.length : 0, 'elements');
					}
					
					if (elemInfos && elemInfos.length > 0) {
						// Use first selected element
						const elem = elemInfos[0];
						const elementGuid = elem[0];
						const elementType = elem[1];
						const elementId = elem[2];
						
						// Update summary display
						updateElementSummary(elementGuid, elementType, elementId);
						
						// Check if element changed
						debugLog('Element check:', { currentElementGuid, elementGuid, changed: currentElementGuid !== elementGuid });
						if (currentElementGuid !== elementGuid) {
							debugLog('Element changed from', currentElementGuid, 'to', elementGuid);
							// Element changed - exit edit mode if active
							if (isEditMode) {
								exitEditMode(false); // Cancel edit mode without saving
							}
							previousElementGuid = currentElementGuid;
			currentElementGuid = elementGuid;
			hasUnsavedChanges = false;
			updateUnsavedIndicator();
			updateUIState();
						}
						
						// Load component info for this element (if not in edit mode)
						if (!isEditMode) {
							if (typeof ACAPI.ComponentInfo_GetComponentInfo === 'function') {
								ACAPI.ComponentInfo_GetComponentInfo(currentElementGuid).then(function (componentInfo) {
									debugLog('ComponentInfo_GetComponentInfo returned:', componentInfo);
									if (componentInfo && Array.isArray(componentInfo) && componentInfo.length >= 5) {
										const componentId = componentInfo[0];
										const photoDescription = componentInfo[1];
										const photoPaths = componentInfo[2];
										const globalId = componentInfo[3];
										const folderName = componentInfo[4];
										
										document.getElementById('component-id').value = componentId || '';
										document.getElementById('photo-description').value = photoDescription || '';
										currentPhotoPaths = photoPaths || [];
										currentGlobalId = globalId || '';
										currentFolderName = folderName || '';
										currentPhotoIndex = 0;
										updatePhotoPreview();
										// Update photo button state based on GlobalId availability
										updatePhotoButtonState();
										// Update view photo button state based on GlobalId and photo availability
										updateViewPhotoButtonState();
										updateGlobalIdStatusIndicator();
										updateUIState();
									}
				}).catch(function (err) {
					debugLog('ComponentInfo_GetComponentInfo failed:', err);
					console.error('Failed to load component info:', err);
					// Don't clear fields on error
					if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
						ACAPI.LogDebug('UpdateSelectedElements: åŠ è½½æ„ä»¶ä¿¡æ¯å¤±è´¥ï¼Œä¿æŒå½“å‰å€¼ï¼Œé”™è¯¯: ' + err);
					}
					updateUIState();
				});
	} else {
								debugLog('ComponentInfo_GetComponentInfo API not available');
								// ComponentInfo_GetComponentInfo API not available
								if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
									ACAPI.LogDebug('UpdateSelectedElements: ComponentInfo_GetComponentInfo API ä¸å¯ç”¨');
								}
								updateUIState();
							}
						} else {
							// In edit mode - don't load component info to prevent overwriting user input
							if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
								ACAPI.LogDebug('UpdateSelectedElements: ç¼–è¾‘æ¨¡å¼ä¸­ï¼Œè·³è¿‡æ„ä»¶ä¿¡æ¯åŠ è½½');
							} else {
								console.log('UpdateSelectedElements: ç¼–è¾‘æ¨¡å¼ä¸­ï¼Œè·³è¿‡æ„ä»¶ä¿¡æ¯åŠ è½½');
							}
						}
					} else {
						debugLog('No element selected, setting currentElementGuid = null');
						// No element selected
						currentElementGuid = null;
						currentGlobalId = '';
						currentPhotoPaths = [];
						
						// Debug logging
						if (typeof ACAPI !== 'undefined' && typeof ACAPI.LogDebug === 'function') {
							ACAPI.LogDebug('UpdateSelectedElements: æ²¡æœ‰é€‰æ‹©å…ƒç´ ï¼Œè®¾ç½® currentElementGuid = null');
						} else {
							console.log('UpdateSelectedElements: æ²¡æœ‰é€‰æ‹©å…ƒç´ ï¼Œè®¾ç½® currentElementGuid = null');
						}
						
						document.getElementById('component-id').value = '';
						document.getElementById('photo-description').value = '';
						updatePhotoButtonState();
						updateViewPhotoButtonState();
						updateGlobalIdStatusIndicator();
						updateUIState();
					}
				});
			}
		}

		function UpdateIFCProperties() {
			// Refresh properties for currently selected element(s)
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function (elemInfos) {
					loadIFCProperties(elemInfos);
				});
			}
		}
	</script>
	<div id="ui-state-indicator" style="font-size: var(--font-size-xs); color: #06b6d4; background: #111; padding: var(--spacing-xs); margin-top: var(--spacing-sm); border-top: 1px solid #333;">
		UIçŠ¶æ€: <span id="ui-state-text">æ£€æµ‹ä¸­...</span>
	</div>
	<div id="debug-output" style="font-size: var(--font-size-xs); color: #666; background: #111; padding: var(--spacing-xs); margin-top: var(--spacing-sm); max-height: 100px; overflow: auto; border-top: 1px solid #333;"></div>
</body>
</html>