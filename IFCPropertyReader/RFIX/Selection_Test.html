<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title>IFC Property Reader</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style type="text/css">
		/* CSS Variables for Industrial Dark Theme */
		:root {
			--bg-dark: #1a1d23;
			--bg-card: #252a33;
			--text-primary: #e2e8f0;
			--text-secondary: #94a3b8;
			--accent: #06b6d4;
			--accent-hover: #22d3ee;
			--border: #3f4a5c;
			--hover: #2d3748;
			--shadow: rgba(0, 0, 0, 0.3);
			--success: #10b981;
			--warning: #f59e0b;
			--error: #ef4444;
			--radius: 4px;
			--transition: all 0.2s ease;
		}

		/* Base Reset */
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
			background-color: var(--bg-dark);
			color: var(--text-primary);
			font-size: 13px;
			line-height: 1.4;
			padding: 12px;
			min-width: 450px;
			min-height: 150px;
			overflow-x: auto;
			user-select: none;
		}

		/* Typography */
		h1, h2, h3 {
			font-weight: 600;
			line-height: 1.2;
		}

		h2 {
			font-size: 14px;
			color: var(--accent);
			margin-bottom: 8px;
			display: flex;
			align-items: center;
			gap: 6px;
		}

		h2::before {
			content: '';
			display: inline-block;
			width: 12px;
			height: 12px;
			background-color: var(--accent);
			border-radius: 2px;
		}

		.plugin-title {
			font-size: 18px;
			font-weight: 600;
			color: #06b6d4; /* var(--accent) */
			margin-bottom: 12px;
			padding-bottom: 8px;
			border-bottom: 2px solid #3f4a5c; /* var(--border) */
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.plugin-title::before {
			content: 'üìã';
			font-size: 16px;
		}

		/* Header Section */
		.header {
			background: #252a33; /* var(--bg-card) */
			border-radius: 4px; /* var(--radius) */
			padding: 12px;
			margin-bottom: 12px;
			border: 1px solid #3f4a5c; /* var(--border) */
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* var(--shadow) */
		}

		.element-summary {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 10px;
			margin-bottom: 12px;
		}

		.summary-item {
			display: flex;
			flex-direction: column;
		}

		.summary-label {
			font-size: 11px;
			color: var(--text-secondary);
			text-transform: uppercase;
			letter-spacing: 0.05em;
			margin-bottom: 2px;
		}

		.summary-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			font-size: 12px;
			background: rgba(0, 0, 0, 0.2);
			padding: 4px 8px;
			border-radius: var(--radius);
			border-left: 3px solid var(--accent);
			word-break: break-all;
		}

		/* Controls Bar */
		.controls {
			display: flex;
			gap: 8px;
			margin-top: 12px;
		}

		.search-box {
			flex: 1;
			position: relative;
		}

		.search-box input {
			width: 100%;
			padding: 6px 10px 6px 32px;
			background: var(--bg-dark);
			border: 1px solid var(--border);
			border-radius: var(--radius);
			color: var(--text-primary);
			font-size: 12px;
			transition: var(--transition);
		}

		.search-box input:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
		}

		.search-box::before {
			content: 'üîç';
			position: absolute;
			left: 10px;
			top: 50%;
			transform: translateY(-50%);
			font-size: 12px;
			color: var(--text-secondary);
			pointer-events: none;
		}

		button {
			background: var(--accent);
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: var(--radius);
			font-size: 12px;
			font-weight: 500;
			cursor: pointer;
			transition: var(--transition);
			display: inline-flex;
			align-items: center;
			gap: 4px;
			white-space: nowrap;
		}

		button:hover {
			background: var(--accent-hover);
			transform: translateY(-1px);
			box-shadow: 0 2px 4px var(--shadow);
		}

		button:active {
			transform: translateY(0);
		}

		button.secondary {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-secondary);
		}

		button.secondary:hover {
			background: var(--hover);
			color: var(--text-primary);
		}

		/* Property Groups */
		.property-groups {
			margin-top: 16px;
			overflow-x: auto;
			max-width: 100%;
		}

		.group {
			background: var(--bg-card);
			border-radius: var(--radius);
			border: 1px solid var(--border);
			margin-bottom: 10px;
			overflow: hidden;
		}

		.group-header {
			padding: 10px 12px;
			background: rgba(63, 74, 92, 0.3);
			display: flex;
			justify-content: space-between;
			align-items: center;
			cursor: pointer;
			transition: var(--transition);
		}

		.group-header:hover {
			background: rgba(63, 74, 92, 0.5);
		}

		.group-header h3 {
			font-size: 13px;
			font-weight: 600;
			color: var(--text-primary);
		}

		.group-badge {
			background: var(--accent);
			color: white;
			font-size: 10px;
			padding: 2px 6px;
			border-radius: 10px;
			font-weight: 600;
		}

		.group-content {
			padding: 0;
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease;
		}

		.group.expanded .group-content {
			max-height: 2000px;
		}

		/* Property Table */
		.property-table {
			width: 100%;
			border-collapse: collapse;
			font-size: 12px;
		}

		.property-table thead {
			background: rgba(0, 0, 0, 0.2);
			border-bottom: 2px solid var(--border);
		}

		.property-table th {
			padding: 8px 10px;
			text-align: left;
			font-weight: 600;
			color: var(--text-secondary);
			text-transform: uppercase;
			font-size: 11px;
			letter-spacing: 0.05em;
		}

		.property-table tbody tr {
			border-bottom: 1px solid rgba(63, 74, 92, 0.3);
			transition: var(--transition);
		}

		.property-table tbody tr:hover {
			background: var(--hover);
		}

		.property-table td {
			padding: 8px 10px;
			vertical-align: top;
		}

		.property-name {
			font-weight: 500;
			color: var(--text-primary);
			min-width: 140px;
		}

		.property-value {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			color: var(--accent);
			word-break: break-word;
			max-width: 200px;
		}

		.property-type {
			color: var(--text-secondary);
			font-style: italic;
			font-size: 11px;
		}

		.property-unit {
			color: var(--success);
			font-size: 11px;
		}

		/* Empty & Loading States */
		.empty-state, .loading-state {
			text-align: center;
			padding: 30px 20px;
			color: var(--text-secondary);
		}

		.empty-state h3, .loading-state h3 {
			color: var(--text-secondary);
			margin-bottom: 8px;
		}

		/* Warning Notification */
		.warning-notice {
			background: rgba(245, 158, 11, 0.1);
			border: 1px solid var(--warning);
			border-radius: var(--radius);
			padding: 8px 12px;
			margin: 10px 0;
			color: var(--warning);
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.warning-notice::before {
			content: '‚ö†Ô∏è';
			font-size: 14px;
		}

		/* Error Notification */
		.error-notice {
			background: rgba(239, 68, 68, 0.1);
			border: 1px solid var(--error);
			border-radius: var(--radius);
			padding: 8px 12px;
			margin: 10px 0;
			color: var(--error);
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		.error-notice::before {
			content: '‚ùå';
			font-size: 14px;
		}

		/* Responsive */
		@media (max-width: 500px) {
			.element-summary {
				grid-template-columns: 1fr;
			}
			.controls {
				flex-wrap: wrap;
			}
			.property-table {
				display: block;
				overflow-x: auto;
			}
		}

		/* Debug Panel */
		.debug-panel {
			background: var(--bg-card);
			border-radius: var(--radius);
			padding: 12px;
			margin-top: 12px;
			border: 1px solid var(--warning);
			box-shadow: 0 2px 4px var(--shadow);
		}

		.debug-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 8px;
			cursor: pointer;
			user-select: none;
		}

		.debug-header h3 {
			font-size: 13px;
			color: var(--warning);
			margin: 0;
			display: flex;
			align-items: center;
			gap: 6px;
		}

		.debug-header h3::before {
			content: 'üêû';
			font-size: 12px;
		}

		.debug-content {
			font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
			font-size: 11px;
			line-height: 1.4;
			max-height: 200px;
			overflow-y: auto;
			background: rgba(0, 0, 0, 0.2);
			padding: 8px;
			border-radius: var(--radius);
			white-space: pre-wrap;
			word-break: break-all;
		}

		.debug-toggle {
			color: var(--text-secondary);
			font-size: 12px;
			transition: var(--transition);
		}

		.debug-toggle:hover {
			color: var(--warning);
		}

		/* Utility */
		.hidden {
			display: none !important;
		}

		.fade-in {
			animation: fadeIn 0.3s ease;
		}

		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}
	</style>
</head>

<body class="palette">
	<div class="header">
		<div class="plugin-title">Â±ûÊÄßÊü•ÁúãËøáÊª§Âô®</div>
		<div class="element-summary">
			<div class="summary-item">
				<div class="summary-label">GUID</div>
				<div id="summary-guid" class="summary-value">{GUID}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Type</div>
				<div id="summary-type" class="summary-value">{Element Type}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Element ID</div>
				<div id="summary-id" class="summary-value">{Element ID}</div>
			</div>
			<div class="summary-item">
				<div class="summary-label">Plugin Version</div>
				<div id="summary-version" class="summary-value">0.2.1.11</div>
			</div>
		</div>
		<div id="multi-selection-warning" class="warning-notice hidden">
			‚ö†Ô∏è Multiple elements selected. Showing properties for the first element only.
		</div>
		<div class="controls">
			<div class="search-box">
				<input type="text" id="property-search" placeholder="Search properties..." />
			</div>
			<button id="refresh-btn" title="Refresh properties">
				‚Üª Refresh
			</button>
		</div>
	</div>

	<div id="loading-state" class="loading-state hidden">
		<h3>Loading IFC properties...</h3>
		<p>Please wait while fetching property data.</p>
	</div>

	<div id="empty-state" class="empty-state hidden">
		<h3>No element selected</h3>
		<p>Select an element in Archicad to view its IFC properties.</p>
	</div>
	
	<div id="no-match-state" class="empty-state hidden">
		<h3>No matching properties</h3>
		<p>Try adjusting your search to find what you're looking for.</p>
	</div>
	
	<div id="error-state" class="error-notice hidden">
		<h3>Error loading IFC properties</h3>
		<p id="error-message">An unexpected error occurred while fetching IFC properties.</p>
		<button id="retry-btn" class="secondary" style="margin-top: 8px;">Retry</button>
	</div>

	<div id="property-groups" class="property-groups">
		<!-- Property groups will be inserted here by JavaScript -->
	</div>
	
	<!-- Debug information panel -->
	<div id="debug-panel" class="debug-panel hidden">
		<div class="debug-header" onclick="toggleDebugPanel()">
			<h3>Debug Information</h3>
			<span class="debug-toggle">‚ñº</span>
		</div>
		<div id="debug-content" class="debug-content">
			<!-- Debug information will be displayed here -->
		</div>
	</div>
	
	<!-- Complete IFC Properties Test Panel -->
	<div id="complete-properties-panel" class="debug-panel" style="margin-top: 12px; border-color: var(--accent);">
		<div class="debug-header" onclick="toggleCompletePropertiesPanel()">
			<h3>Complete IFC Properties Test</h3>
			<span class="debug-toggle">‚ñº</span>
		</div>
		<div id="complete-properties-content" class="debug-content" style="display: none;">
			<p>Test the new GetAllIFCProperties function that reads ALL IFC properties including local, preview, attributes, and classifications.</p>
			<div style="display: flex; gap: 8px; margin-top: 8px;">
				<button onclick="testCompleteIFCProperties()" style="background: var(--success);">Test Complete Properties</button>
				<button onclick="comparePropertyCounts()" class="secondary">Compare Counts</button>
			</div>
			<div id="complete-properties-result" style="margin-top: 12px; font-family: monospace; font-size: 11px;"></div>
		</div>
	</div>
	

	
	<!-- Hidden debug form for AddElementToSelection (kept for compatibility) -->
	<div id="debug-form" style="display: none;">
		<input type="text" id="elemGuidToAdd" size="40">
		<input type="button" onclick="AddElementToSelection()" value="+">
	</div>

	<script type="text/javascript">
		// Mock data for demonstration
		const mockPropertyData = {
			guid: "{335B0B7A-1234-5678-ABCD-EF0123456789}",
			type: "IfcWall",
			elementId: "1001",
			properties: [
				{
					schema: "IFC4",
					category: "General",
					name: "Name",
					value: "Interior Wall 001",
					type: "IfcLabel",
					unit: null
				},
				{
					schema: "IFC4",
					category: "General",
					name: "Description",
					value: "Load bearing wall with fire rating",
					type: "IfcText",
					unit: null
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Length",
					value: "5000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC4",
					category: "Dimensions",
					name: "Height",
					value: "3000.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Material",
					value: "Concrete",
					type: "IfcMaterial",
					unit: null
				},
				{
					schema: "IFC2x3",
					category: "Materials",
					name: "Thickness",
					value: "200.0",
					type: "IfcLengthMeasure",
					unit: "mm"
				},
				{
					schema: "IFC2x3",
					category: "Performance",
					name: "Fire Rating",
					value: "120",
					type: "IfcTimeMeasure",
					unit: "minutes"
				}
			]
		};

		let currentProperties = []; // Holds properties for currently selected element, initially empty
		let debugInfo = {}; // Store debug information for display
		
		// Debug panel functions
		function toggleDebugPanel() {
			const panel = document.getElementById('debug-panel');
			const content = document.getElementById('debug-content');
			const toggle = panel.querySelector('.debug-toggle');
			
			if (content.style.display === 'none' || content.style.display === '') {
				content.style.display = 'block';
				toggle.textContent = '‚ñ≤';
				// Update debug info when showing panel
				updateDebugInfo();
			} else {
				content.style.display = 'none';
				toggle.textContent = '‚ñº';
			}
		}
		
		function updateDebugInfo() {
			const debugContent = document.getElementById('debug-content');
			if (!debugContent) return;
			
			let debugText = '';
			
			// Add timestamp
			debugText += `Time: ${new Date().toLocaleTimeString()}\n`;
			debugText += `Selected: ${currentProperties.length > 0 ? 'Yes' : 'No'}\n`;
			debugText += `Properties count: ${currentProperties.length}\n\n`;
			
			// Add debug info from properties
			const debugProperties = currentProperties.filter(p => 
				p.category === 'DEBUG_INFO' || 
				p.category === 'IFC_IDENTIFIER' ||
				p.category === 'IFC_IDENTIFIER'
			);
			
			if (debugProperties.length > 0) {
				debugText += "=== DEBUG INFO FROM C++ ===\n";
				debugProperties.forEach(prop => {
					debugText += `${prop.category}.${prop.name} = ${prop.value}\n`;
				});
				debugText += "\n";
			}
			
			// Add property statistics
			const categories = {};
			currentProperties.forEach(prop => {
				if (prop.category !== 'DEBUG_INFO') {
					categories[prop.category] = (categories[prop.category] || 0) + 1;
				}
			});
			
			if (Object.keys(categories).length > 0) {
				debugText += "=== PROPERTY CATEGORIES ===\n";
				Object.entries(categories).forEach(([cat, count]) => {
					debugText += `${cat}: ${count} properties\n`;
				});
			}
			
			// Show if GlobalId/Archicad_IFC_ID was found
			const ifcIdProp = currentProperties.find(p => 
				p.name === 'Archicad_IFC_ID' || 
				(p.category === 'DEBUG_INFO' && p.name === 'GlobalId_Found')
			);
			
			if (ifcIdProp) {
				debugText += `\nArchicad IFC ID found: ${ifcIdProp.value}\n`;
			} else {
				debugText += "\nArchicad IFC ID: NOT FOUND\n";
			}
			
			// Show Pset_ColumnCommon status
			const psetProp = currentProperties.find(p => 
				p.category === 'DEBUG_INFO' && p.name === 'Pset_ColumnCommon_Found'
			);
			
			if (psetProp) {
				debugText += `Pset_ColumnCommon: ${psetProp.value === 'true' ? 'FOUND' : 'NOT FOUND'}\n`;
			} else {
				debugText += "Pset_ColumnCommon: NO DEBUG INFO\n";
			}
			
			debugContent.textContent = debugText;
		}
		
		function showDebugPanel() {
			const panel = document.getElementById('debug-panel');
			panel.classList.remove('hidden');
			updateDebugInfo();
		}
		
		function hideDebugPanel() {
			const panel = document.getElementById('debug-panel');
			panel.classList.add('hidden');
		}
		
		// Transform C++ property array format to UI property object format
		// C++ format: [propertySetName, propertyName, propertyValue, propertyType, unit, isValid]
		// UI format: {schema, category, name, value, type, unit}
		function transformCppPropertiesToUI(cppProperties) {
			console.log('transformCppPropertiesToUI called with:', cppProperties);
			if (!cppProperties) {
				console.warn('cppProperties is null or undefined');
				return [];
			}
			if (!Array.isArray(cppProperties)) {
				console.warn('cppProperties is not an array:', typeof cppProperties, cppProperties);
				return [];
			}
			console.log(`Received ${cppProperties.length} properties from C++ backend`);
			const uiProperties = [];
			for (let i = 0; i < cppProperties.length; i++) {
				const prop = cppProperties[i];
				if (!Array.isArray(prop) || prop.length < 6) {
					console.warn(`Property at index ${i} is invalid:`, prop);
					continue;
				}
				const [propertySetName, propertyName, propertyValue, propertyType, unit, isValid] = prop;
				// Filter out invalid properties
				if (isValid === false) {
					console.log(`Property ${propertySetName}.${propertyName} is invalid (isValid=false), skipping`);
					continue;
				}
				// Map propertySetName -> category
				// For schema, we can try to extract IFC version from propertySetName, default to "IFC"
				let schema = "IFC";
				const schemaMatch = propertySetName.match(/IFC(2X3|4|2x3)?/i);
				if (schemaMatch) schema = schemaMatch[0].toUpperCase();
				uiProperties.push({
					schema: schema,
					category: propertySetName,
					name: propertyName,
					value: propertyValue,
					type: propertyType,
					unit: unit || null
				});
				// Log DEBUG_INFO properties
				if (propertySetName === 'DEBUG_INFO') {
					console.log(`DEBUG_INFO: ${propertyName} = ${propertyValue}`);
				}
			}
			console.log(`Transformed to ${uiProperties.length} UI properties`);
			return uiProperties;
		}
		
		// Êõ¥Êñ∞ÁâàÊú¨ÊòæÁ§∫
		function updateVersionDisplay(properties) {
			const versionElement = document.getElementById('summary-version');
			if (!versionElement) return;
			
			// Êü•ÊâæADDON_INFOÁªÑ‰∏≠ÁöÑVersionÂ±ûÊÄß
			const versionProperty = properties.find(prop => 
				prop.category === 'ADDON_INFO' && prop.name === 'Version'
			);
			
			if (versionProperty) {
				versionElement.textContent = versionProperty.value;
			} else {
				// Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÁâàÊú¨Â±ûÊÄßÔºå‰øùÊåÅÈªòËÆ§ÂÄº
				versionElement.textContent = 'unknown';
			}
		}
		
		// Êõ¥Êñ∞Êèí‰ª∂ÁâàÊú¨ÊòæÁ§∫
		function updatePluginVersion() {
			const versionElement = document.getElementById('summary-version');
			if (!versionElement) return;
			
			// Ê∏ÖÈô§ÁºìÂ≠òÔºåÈÅøÂÖçÊóßÁâàÊú¨‰ø°ÊÅØÊÆãÁïô
			if (typeof ACAPI !== 'undefined' && ACAPI.ClearIFCPropertyCache) {
				ACAPI.ClearIFCPropertyCache();
			}
			
			// Ëé∑ÂèñÊèí‰ª∂ÁâàÊú¨
			if (typeof ACAPI !== 'undefined' && ACAPI.GetPluginVersion) {
				ACAPI.GetPluginVersion().then(version => {
					console.log('Plugin version from C++:', version);
					versionElement.textContent = version;
				}).catch(error => {
					console.warn('Failed to get plugin version:', error);
					versionElement.textContent = 'unknown';
				});
			} else {
				// ACAPI not available, use default
				versionElement.textContent = '0.2.1.11';
			}
		}
		
		// Group properties by category (propertySetName)
		function groupProperties(properties) {
			const groups = {};
			properties.forEach(prop => {
				const key = prop.category; // propertySetName
				if (!groups[key]) {
					groups[key] = {
						schema: prop.schema,
						category: prop.category,
						properties: []
					};
				}
				groups[key].properties.push(prop);
			});
			return Object.values(groups);
		}

		// Render property groups
		function renderPropertyGroups(groups) {
			const container = document.getElementById('property-groups');
			container.innerHTML = '';

			if (groups.length === 0) {
				// Check if we have an element selected (empty-state hidden)
				const emptyState = document.getElementById('empty-state');
				if (emptyState.classList.contains('hidden')) {
					// Element is selected but no properties match filter
					document.getElementById('no-match-state').classList.remove('hidden');
				} else {
					// No element selected
					emptyState.classList.remove('hidden');
				}
				return;
			} else {
				// Hide both empty and no-match states
				document.getElementById('empty-state').classList.add('hidden');
				document.getElementById('no-match-state').classList.add('hidden');
			}

			// Lazy rendering: render groups in batches for better performance
			const batchSize = 3; // Render 3 groups per frame
			let currentIndex = 0;
			
			function renderNextBatch() {
				const batch = groups.slice(currentIndex, currentIndex + batchSize);
				currentIndex += batchSize;
				
				batch.forEach(group => {
					const groupElement = document.createElement('div');
					groupElement.className = 'group expanded';
					groupElement.innerHTML = `
						<div class="group-header" onclick="toggleGroup(this.parentElement)">
							<h3>${group.category}</h3>
							<span class="group-badge">${group.properties.length}</span>
						</div>
						<div class="group-content">
							<table class="property-table">
								<thead>
									<tr>
										<th>Property Name</th>
										<th>Value</th>
										<th>Type</th>
										<th>Unit</th>
									</tr>
								</thead>
								<tbody>
									${group.properties.map(prop => `
										<tr>
											<td class="property-name">${prop.name}</td>
											<td class="property-value">${prop.value}</td>
											<td class="property-type">${prop.type}</td>
											<td class="property-unit">${prop.unit || '‚Äî'}</td>
										</tr>
									`).join('')}
								</tbody>
							</table>
						</div>
					`;
					container.appendChild(groupElement);
				});
				
				// If there are more groups to render, schedule next batch
				if (currentIndex < groups.length) {
					requestAnimationFrame(renderNextBatch);
				}
			}
			
			// Start rendering
			requestAnimationFrame(renderNextBatch);
		}

		// Toggle group expansion
		function toggleGroup(groupElement) {
			groupElement.classList.toggle('expanded');
		}

		// Filter properties based on search input
		function filterProperties(searchTerm) {
			const filtered = currentProperties.filter(prop => 
				prop.name.toLowerCase().includes(searchTerm) ||
				prop.value.toLowerCase().includes(searchTerm) ||
				prop.type.toLowerCase().includes(searchTerm) ||
				prop.category.toLowerCase().includes(searchTerm)
			);
			const groups = groupProperties(filtered);
			renderPropertyGroups(groups);
		}

		// Update summary from selected element
		function updateElementSummary(guid, type, elementId) {
			document.getElementById('summary-guid').textContent = guid;
			document.getElementById('summary-type').textContent = type;
			document.getElementById('summary-id').textContent = elementId;
		}

		// Show loading state
		function showLoading() {
			document.getElementById('loading-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('error-state').classList.add('hidden');
		}

		// Hide loading state
		function hideLoading() {
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('property-groups').classList.remove('hidden');
		}

		// Show error state
		function showError(errorMessage) {
			document.getElementById('error-message').textContent = errorMessage || 'An unexpected error occurred while fetching IFC properties.';
			document.getElementById('error-state').classList.remove('hidden');
			document.getElementById('property-groups').classList.add('hidden');
			document.getElementById('loading-state').classList.add('hidden');
			document.getElementById('empty-state').classList.add('hidden');
			document.getElementById('no-match-state').classList.add('hidden');
		}

		// Main function to load and display properties
		function loadIFCProperties(elementInfos) {
			showLoading();

			// Simulate API delay (keep for fallback)
			setTimeout(() => {
				if (!elementInfos || elementInfos.length === 0) {
					document.getElementById('empty-state').classList.remove('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					document.getElementById('property-groups').classList.add('hidden');
					updateElementSummary('‚Äî', '‚Äî', '‚Äî');
					currentProperties = [];
					// Hide multi-selection warning
					document.getElementById('multi-selection-warning').classList.add('hidden');
					// Hide debug panel when no element selected
					hideDebugPanel();
					hideLoading();
					return;
				}
				
				// Show/hide multi-selection warning
				const warning = document.getElementById('multi-selection-warning');
				if (elementInfos.length > 1) {
					warning.classList.remove('hidden');
				} else {
					warning.classList.add('hidden');
				}
				
				// Use first selected element
				const elem = elementInfos[0];
				const elementGuid = elem[0];
				updateElementSummary(elem[0], elem[1], elem[2]);
				
				// Try to fetch real IFC properties from C++ backend
				if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetAllIFCProperties === 'function') {
					console.log('ACAPI.GetAllIFCProperties available, calling with elementGuid:', elementGuid);
					ACAPI.GetAllIFCProperties(elementGuid)
						.then(cppProperties => {
							console.log('ACAPI.GetAllIFCProperties returned:', cppProperties);
							// Transform C++ property format to UI format
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							console.log('After transformation:', uiProperties.length, 'UI properties');
							if (uiProperties.length === 0) {
								// If no properties returned, fall back to mock data for testing
								console.warn('No IFC properties returned from backend, using mock data for demonstration');
								console.warn('Raw C++ properties that were received:', cppProperties);
								currentProperties = mockPropertyData.properties;
							} else {
								console.log('Using real IFC properties from backend');
								currentProperties = uiProperties;
							}
							// Update debug info and show debug panel
							updateDebugInfo();
							showDebugPanel();
							
							const groups = groupProperties(currentProperties);
							console.log('Grouped into', groups.length, 'groups');
							renderPropertyGroups(groups);
							document.getElementById('empty-state').classList.add('hidden');
							document.getElementById('no-match-state').classList.add('hidden');
							hideLoading();
						})
						.catch(error => {
							console.error('Failed to fetch IFC properties:', error);
							// Show error to user
							showError(`Failed to fetch IFC properties: ${error.message || error}`);
							hideLoading();
						});
				} else {
					// ACAPI not available, use mock data (for testing outside Archicad)
					console.warn('ACAPI not available, using mock data for demonstration');
					currentProperties = mockPropertyData.properties;
					// Update debug info and show debug panel
					updateDebugInfo();
					showDebugPanel();
					
					const groups = groupProperties(currentProperties);
					renderPropertyGroups(groups);
					document.getElementById('empty-state').classList.add('hidden');
					document.getElementById('no-match-state').classList.add('hidden');
					hideLoading();
				}
			}, 300);
		}

		// Event listeners
		document.addEventListener('DOMContentLoaded', function() {
			// ÂàùÂßãÂåñÊèí‰ª∂ÁâàÊú¨ÊòæÁ§∫
			updatePluginVersion();
			
			// Search input
			const searchInput = document.getElementById('property-search');
			searchInput.addEventListener('input', function(e) {
				filterProperties(e.target.value.toLowerCase());
			});

			// Refresh button
			document.getElementById('refresh-btn').addEventListener('click', function() {
				// In real implementation, re-fetch properties for current selection
				ACAPI.GetSelectedElements().then(loadIFCProperties);
			});

			// Retry button for error state
			document.getElementById('retry-btn').addEventListener('click', function() {
				document.getElementById('error-state').classList.add('hidden');
				ACAPI.GetSelectedElements().then(loadIFCProperties);
			});

			// Initial load - no element selected
			// Show empty state initially
			document.getElementById('empty-state').classList.remove('hidden');
			// Clear any previous properties
			currentProperties = [];
			// Hide debug panel initially
			hideDebugPanel();
			const groups = groupProperties(currentProperties);
			renderPropertyGroups(groups);
		});

		// Keep existing ACAPI bridge functions
		function UpdateSelectedElements() {
			ACAPI.GetSelectedElements().then(function (elemInfos) {
				loadIFCProperties(elemInfos);
			});
		}

		function UpdateIFCProperties() {
			// Refresh properties for currently selected element(s)
			ACAPI.GetSelectedElements().then(function (elemInfos) {
				loadIFCProperties(elemInfos);
			});
		}

		function AddElementToSelection() {
			var elemGuidToAddInput = document.getElementById('elemGuidToAdd');
			ACAPI.AddElementToSelection(elemGuidToAddInput.value).then(function (res) {
				elemGuidToAddInput.value = '';
			});
		}

		// Test functions for development (can be called from console)
		window.testIFCProperties = {
			// Test with mock selection
			testSingleElement: function() {
				const mockSelection = [
					["{335B0B7A-1234-5678-ABCD-EF0123456789}", "IfcWall", "1001"]
				];
				loadIFCProperties(mockSelection);
				console.log("Test: Single element selection loaded");
			},
			
			// Test with multiple elements
			testMultipleElements: function() {
				const mockSelection = [
					["{335B0B7A-1234-5678-ABCD-EF0123456789}", "IfcWall", "1001"],
					["{445B0B7A-1234-5678-ABCD-EF0123456789}", "IfcDoor", "1002"]
				];
				loadIFCProperties(mockSelection);
				console.log("Test: Multiple elements selection loaded");
			},
			
			// Test empty selection
			testEmptySelection: function() {
				loadIFCProperties([]);
				console.log("Test: Empty selection loaded");
			},
			
			// Test search functionality
			testSearch: function(term) {
				const searchInput = document.getElementById('property-search');
				searchInput.value = term || "wall";
				searchInput.dispatchEvent(new Event('input'));
				console.log("Test: Search for '" + (term || "wall") + "' executed");
			},
			
			// Test with simulated C++ property data
			testRealCppProperties: function() {
				// Simulate C++ property array format: [propertySetName, propertyName, propertyValue, propertyType, unit, isValid]
				const cppProps = [
					["Pset_WallCommon", "Reference", "INT-001", "IfcLabel", null, true],
					["Pset_WallCommon", "FireRating", "120", "IfcTimeMeasure", "minutes", true],
					["Pset_WallCommon", "LoadBearing", true, "IfcBoolean", null, true],
					["IFC4::IfcWall", "Name", "Interior Wall", "IfcLabel", null, true],
					["IFC4::IfcWall", "Description", "Load bearing wall", "IfcText", null, true],
					["InvalidSet", "SomeProperty", "Value", "IfcLabel", null, false] // invalid, should be filtered out
				];
				console.log("Testing C++ property transformation...");
				const uiProps = transformCppPropertiesToUI(cppProps);
				console.log("Transformed properties:", uiProps);
				console.log("Filtered invalid:", uiProps.length === 5 ? "OK" : "FAIL");
				// Test grouping
				const groups = groupProperties(uiProps);
				console.log("Groups:", groups);
				console.log("Group count:", groups.length);
				console.log("Group categories:", groups.map(g => g.category));
				// Update UI with test data
				currentProperties = uiProps;
				const groups2 = groupProperties(currentProperties);
				renderPropertyGroups(groups2);
				updateElementSummary("{TEST-GUID}", "IfcWall", "9999");
				console.log("Test completed - UI updated with simulated C++ data");
			},
			
			// Test error handling
			testErrorHandling: function() {
				console.log("Testing error handling...");
				// Simulate an API error
				showError("Test error: Failed to fetch IFC properties from backend");
				console.log("Error state should be visible");
			},
			
			// Test IFC type retrieval (testing GetIFCType() API)
			testIFCTypeRetrieval: function() {
				console.log("Testing IFC type retrieval...");
				// Simulate C++ property array with IFC_ENTITY.IFC_Type property
				const cppProps = [
					["Pset_WallCommon", "Reference", "INT-001", "IfcLabel", null, true],
					["Pset_WallCommon", "FireRating", "120", "IfcTimeMeasure", "minutes", true],
					["IFC_ENTITY", "IFC_Type", "IfcWall", "IfcEntity", null, true], // IFC type from GetIFCType()
					["IFC_BASIC", "Name", "Interior Wall", "IfcLabel", null, true],
					["IFC_IDENTIFIER", "Archicad_IFC_ID", "WALL-001", "IfcIdentifier", null, true]
				];
				console.log("Testing IFC type property in C++ data...");
				const uiProps = transformCppPropertiesToUI(cppProps);
				
				// Verify IFC_Type property exists
				const ifcTypeProp = uiProps.find(p => p.name === "IFC_Type" && p.category === "IFC_ENTITY");
				console.log("IFC_Type property found:", ifcTypeProp ? "YES" : "NO");
				if (ifcTypeProp) {
					console.log("IFC_Type value:", ifcTypeProp.value);
					console.log("IFC_Type type:", ifcTypeProp.type);
				}
				
				// Verify Archicad_IFC_ID exists
				const ifcIdProp = uiProps.find(p => p.name === "Archicad_IFC_ID" && p.category === "IFC_IDENTIFIER");
				console.log("Archicad_IFC_ID found:", ifcIdProp ? "YES" : "NO");
				if (ifcIdProp) {
					console.log("Archicad_IFC_ID value:", ifcIdProp.value);
				}
				
				// Verify Name property exists
				const nameProp = uiProps.find(p => p.name === "Name" && p.category === "IFC_BASIC");
				console.log("Name property found:", nameProp ? "YES" : "NO");
				if (nameProp) {
					console.log("Name value:", nameProp.value);
				}
				
				// Update UI with test data
				currentProperties = uiProps;
				const groups = groupProperties(currentProperties);
				renderPropertyGroups(groups);
				updateElementSummary("{TEST-IFC-TYPE-GUID}", "IfcWall", "8888");
				console.log("IFC type retrieval test completed");
			},
			
			// Test Chinese tag property support
			testChineseTagSupport: function() {
				console.log("Testing Chinese tag property support...");
				// Simulate C++ property array with Chinese property names
				const cppProps = [
					["Pset_WallCommon", "Reference", "INT-001", "IfcLabel", null, true],
					["Pset_WallCommon", "ÂêçÁß∞", "WALL-001-CN", "IfcIdentifier", null, true], // Chinese "ÂêçÁß∞" for Tag
					["Pset_WallCommon", "Ê†áÁ≠æ", "WALL-001-TAG", "IfcIdentifier", null, true], // Chinese "Ê†áÁ≠æ" for Tag
					["Pset_WallCommon", "Name", "Interior Wall", "IfcLabel", null, true],
					["IFC_ENTITY", "IFC_Type", "IfcWall", "IfcEntity", null, true]
				];
				console.log("Testing Chinese property name recognition...");
				const uiProps = transformCppPropertiesToUI(cppProps);
				
				// The transform function doesn't handle Chinese property names specially,
				// but the C++ backend should find them as Tag properties
				console.log("Total properties:", uiProps.length);
				
				// Check if Chinese properties are included
				const chineseNameProp = uiProps.find(p => p.name === "ÂêçÁß∞");
				console.log("Chinese 'ÂêçÁß∞' property found:", chineseNameProp ? "YES" : "NO");
				if (chineseNameProp) {
					console.log("Chinese 'ÂêçÁß∞' value:", chineseNameProp.value);
				}
				
				const chineseTagProp = uiProps.find(p => p.name === "Ê†áÁ≠æ");
				console.log("Chinese 'Ê†áÁ≠æ' property found:", chineseTagProp ? "YES" : "NO");
				if (chineseTagProp) {
					console.log("Chinese 'Ê†áÁ≠æ' value:", chineseTagProp.value);
				}
				
				// Note: The actual Tag property mapping happens in C++ backend,
				// this test just verifies the properties are passed through correctly
				
				// Update UI with test data
				currentProperties = uiProps;
				const groups = groupProperties(currentProperties);
				renderPropertyGroups(groups);
				updateElementSummary("{TEST-CHINESE-GUID}", "IfcWall", "7777");
				console.log("Chinese tag support test completed");
			},
			
			// Test version display functionality
			testVersionDisplay: function() {
				console.log("Testing version display functionality...");
				// Simulate C++ property array with ADDON_INFO.Version property
				const cppProps = [
					["Pset_WallCommon", "Reference", "INT-001", "IfcLabel", null, true],
					["ADDON_INFO", "Version", "0.2.1.11", "String", null, true], // Version from GetAddOnVersionString()
					["IFC_ENTITY", "IFC_Type", "IfcWall", "IfcEntity", null, true],
					["IFC_IDENTIFIER", "Archicad_IFC_ID", "WALL-001", "IfcIdentifier", null, true]
				];
				console.log("Testing version property in C++ data...");
				const uiProps = transformCppPropertiesToUI(cppProps);
				
				// Verify Version property exists
				const versionProp = uiProps.find(p => p.name === "Version" && p.category === "ADDON_INFO");
				console.log("Version property found:", versionProp ? "YES" : "NO");
				if (versionProp) {
					console.log("Version value:", versionProp.value);
					console.log("Expected: 0.2.1.11, Actual:", versionProp.value);
					
					// Test updateVersionDisplay function
					updateVersionDisplay(uiProps);
					const versionElement = document.getElementById('summary-version');
					if (versionElement) {
						console.log("UI Version element text:", versionElement.textContent);
						console.log("UI Version matches property:", versionElement.textContent === versionProp.value ? "YES" : "NO");
					}
				}
				
				// Update UI with test data
				currentProperties = uiProps;
				const groups = groupProperties(currentProperties);
				renderPropertyGroups(groups);
				updateElementSummary("{TEST-VERSION-GUID}", "IfcWall", "6666");
				console.log("Version display test completed");
			},
			
			// Test lazy loading performance with large dataset
			testLazyLoading: function() {
				console.log("Testing lazy loading with large dataset...");
				// Create a large mock dataset (100 properties across 10 groups)
				const largeMockData = {
					guid: "{TEST-LARGE-GUID}",
					type: "IfcBuilding",
					elementId: "9999",
					properties: []
				};
				
				// Generate 100 properties across 10 different property sets
				for (let i = 1; i <= 10; i++) {
					const category = `Pset_Test${i}`;
					for (let j = 1; j <= 10; j++) {
						largeMockData.properties.push({
							schema: "IFC4",
							category: category,
							name: `Property${j}`,
							value: `Value${j}`,
							type: "IfcLabel",
							unit: null
						});
					}
				}
				
				// Use the large dataset
				currentProperties = largeMockData.properties;
				const groups = groupProperties(currentProperties);
				console.log(`Generated ${largeMockData.properties.length} properties in ${groups.length} groups`);
				console.log("Rendering with lazy loading (batch size: 3 groups per frame)...");
				renderPropertyGroups(groups);
				updateElementSummary(largeMockData.guid, largeMockData.type, largeMockData.elementId);
				console.log("Lazy loading test completed");
			},
			
			// Run all tests
			runAllTests: function() {
				console.log("=== Running IFC Property Reader Test Suite ===");
				this.validateData();
				this.testSingleElement();
				this.testMultipleElements();
				this.testEmptySelection();
				this.testSearch("test");
				this.testRealCppProperties();
				this.testErrorHandling();
				this.testIFCTypeRetrieval();
				this.testChineseTagSupport();
				this.testVersionDisplay();
				this.testLazyLoading();
				console.log("=== All tests completed ===");
			},
			
			// Validate mock data structure
			validateData: function() {
				const props = mockPropertyData.properties;
				console.log("Validating mock data:");
				console.log("- Total properties:", props.length);
				console.log("- Unique schemas:", [...new Set(props.map(p => p.schema))]);
				console.log("- Unique categories:", [...new Set(props.map(p => p.category))]);
				console.log("- Data structure OK:", props.every(p => 
					p.schema && p.category && p.name && p.value && p.type !== undefined
				));
			}
		};
		
		// Complete IFC Properties test functions
		function toggleCompletePropertiesPanel() {
			const panel = document.getElementById('complete-properties-panel');
			const content = document.getElementById('complete-properties-content');
			const toggle = panel.querySelector('.debug-toggle');
			
			if (content.style.display === 'none' || content.style.display === '') {
				content.style.display = 'block';
				toggle.textContent = '‚ñ≤';
			} else {
				content.style.display = 'none';
				toggle.textContent = '‚ñº';
			}
		}
		
		function testCompleteIFCProperties() {
			const resultDiv = document.getElementById('complete-properties-result');
			resultDiv.innerHTML = 'Testing complete IFC properties...<br>';
			
			// First get selected element
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function(elemInfos) {
					if (!elemInfos || elemInfos.length === 0) {
						resultDiv.innerHTML += '‚ùå No element selected. Please select an element in Archicad.<br>';
						return;
					}
					
					// Use first element
					const elem = elemInfos[0];
					const elementGuid = elem[0];
					resultDiv.innerHTML += `Testing element: ${elementGuid}<br>`;
					
					// Call the new GetAllIFCProperties function
					if (typeof ACAPI.GetAllIFCProperties === 'function') {
						ACAPI.GetAllIFCProperties(elementGuid).then(function(cppProperties) {
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							resultDiv.innerHTML += `‚úÖ Success! Retrieved ${uiProperties.length} properties.<br>`;
							resultDiv.innerHTML += `Property breakdown:<br>`;
							
							// Count by category
							const categories = {};
							uiProperties.forEach(prop => {
								const cat = prop.category;
								categories[cat] = (categories[cat] || 0) + 1;
							});
							
							// Sort by count descending
							const sortedCats = Object.entries(categories).sort((a, b) => b[1] - a[1]);
							
							sortedCats.forEach(([cat, count]) => {
								resultDiv.innerHTML += `  ‚Ä¢ ${cat}: ${count} properties<br>`;
							});
							
							// Show sample properties
							resultDiv.innerHTML += `<br>Sample properties (first 5):<br>`;
							uiProperties.slice(0, 5).forEach((prop, i) => {
								resultDiv.innerHTML += `  ${i+1}. ${prop.category}.${prop.name} = ${prop.value} (${prop.type})<br>`;
							});
							
							// Update current properties to show in UI
							currentProperties = uiProperties;
							const groups = groupProperties(currentProperties);
							renderPropertyGroups(groups);
							updateElementSummary(elementGuid, elem[1], elem[2]);
							
						}).catch(function(error) {
							resultDiv.innerHTML += `‚ùå Error calling GetAllIFCProperties: ${error}<br>`;
							resultDiv.innerHTML += 'Make sure the new C++ function is compiled and loaded.<br>';
						});
					} else {
						resultDiv.innerHTML += '‚ùå ACAPI.GetAllIFCProperties function not available.<br>';
						resultDiv.innerHTML += 'Make sure the plugin is rebuilt with the new function.<br>';
					}
				});
			} else {
				resultDiv.innerHTML += '‚ùå ACAPI not available (testing outside Archicad?).<br>';
				resultDiv.innerHTML += 'Using mock data for demonstration.<br>';
				
				// Mock test
				const mockProps = [
					["Pset_WallCommon [Local]", "Reference", "INT-001", "IfcLabel", null, true],
					["Pset_WallCommon [Preview]", "FireRating", "120", "IfcTimeMeasure", "minutes", true],
					["IFC_Attributes", "Name", "Test Wall", "IfcLabel", null, true],
					["Classification", "Uniclass", "Pr_20_30_10", "IfcClassificationReference", null, true],
					["IFC_ENTITY", "IFC_Type", "IfcWall", "IfcEntity", null, true],
					["STATISTICS", "Total_Properties_Count", "5", "Integer", null, true]
				];
				
				const uiProperties = transformCppPropertiesToUI(mockProps);
				resultDiv.innerHTML += `‚úÖ Mock test: Retrieved ${uiProperties.length} properties.<br>`;
				
				currentProperties = uiProperties;
				const groups = groupProperties(currentProperties);
				renderPropertyGroups(groups);
				updateElementSummary("{MOCK-GUID}", "IfcWall", "9999");
			}
		}
		
		function comparePropertyCounts() {
			const resultDiv = document.getElementById('complete-properties-result');
			resultDiv.innerHTML = 'Comparing property counts...<br>';
			
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function(elemInfos) {
					if (!elemInfos || elemInfos.length === 0) {
						resultDiv.innerHTML += '‚ùå No element selected.<br>';
						return;
					}
					
					const elem = elemInfos[0];
					const elementGuid = elem[0];
					
					// Get properties using old method
					if (typeof ACAPI.GetIFCProperties === 'function') {
						ACAPI.GetIFCProperties().then(function(oldProps) {
							const oldCount = oldProps ? oldProps.length : 0;
							
							// Get properties using new method
							if (typeof ACAPI.GetAllIFCProperties === 'function') {
								ACAPI.GetAllIFCProperties(elementGuid).then(function(newProps) {
									const newCount = newProps ? newProps.length : 0;
									const diff = newCount - oldCount;
									
									resultDiv.innerHTML += `Property count comparison:<br>`;
									resultDiv.innerHTML += `‚Ä¢ Old method (GetIFCProperties): ${oldCount} properties<br>`;
									resultDiv.innerHTML += `‚Ä¢ New method (GetAllIFCProperties): ${newCount} properties<br>`;
									resultDiv.innerHTML += `‚Ä¢ Difference: ${diff} additional properties<br>`;
									
									if (diff > 0) {
										resultDiv.innerHTML += `‚úÖ New method found ${diff} more properties!<br>`;
									} else if (diff === 0) {
										resultDiv.innerHTML += `‚ö†Ô∏è Both methods returned same number of properties.<br>`;
									} else {
										resultDiv.innerHTML += `‚ö†Ô∏è Unexpected: New method returned fewer properties.<br>`;
									}
									
								}).catch(function(error) {
									resultDiv.innerHTML += `‚ùå Error calling GetAllIFCProperties: ${error}<br>`;
								});
							} else {
								resultDiv.innerHTML += '‚ùå GetAllIFCProperties not available.<br>';
							}
						}).catch(function(error) {
							resultDiv.innerHTML += `‚ùå Error calling GetIFCProperties: ${error}<br>`;
						});
					} else {
						resultDiv.innerHTML += '‚ùå GetIFCProperties not available.<br>';
					}
				});
			} else {
				resultDiv.innerHTML += '‚ùå ACAPI not available.<br>';
			}
		}
		
		// Cache performance test functions
		function toggleCachePerformancePanel() {
			const panel = document.getElementById('cache-performance-panel');
			const content = document.getElementById('cache-performance-content');
			const toggle = panel.querySelector('.debug-toggle');
			
			if (content.style.display === 'none' || content.style.display === '') {
				content.style.display = 'block';
				toggle.textContent = '‚ñ≤';
			} else {
				content.style.display = 'none';
				toggle.textContent = '‚ñº';
			}
		}
		
		function testCachedProperties() {
			const resultDiv = document.getElementById('performance-test-result');
			const statsDiv = document.getElementById('cache-stats-result');
			resultDiv.innerHTML = 'Testing cached properties...<br>';
			
			// First get selected element
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function(elemInfos) {
					if (!elemInfos || elemInfos.length === 0) {
						resultDiv.innerHTML += '‚ùå No element selected. Please select an element in Archicad.<br>';
						return;
					}
					
					const elem = elemInfos[0];
					const elementGuid = elem[0];
					resultDiv.innerHTML += `Testing element: ${elementGuid}<br>`;
					
					// First call (should miss cache)
					const startTime1 = performance.now();
					if (typeof ACAPI.GetCachedIFCProperties === 'function') {
						ACAPI.GetCachedIFCProperties(elementGuid).then(function(cppProperties) {
							const endTime1 = performance.now();
							const time1 = endTime1 - startTime1;
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							
							resultDiv.innerHTML += `First call (cache miss): ${uiProperties.length} properties in ${time1.toFixed(2)}ms<br>`;
							
							// Second call (should hit cache)
							const startTime2 = performance.now();
							ACAPI.GetCachedIFCProperties(elementGuid).then(function(cppProperties2) {
								const endTime2 = performance.now();
								const time2 = endTime2 - startTime2;
								const uiProperties2 = transformCppPropertiesToUI(cppProperties2);
								
								resultDiv.innerHTML += `Second call (cache hit): ${uiProperties2.length} properties in ${time2.toFixed(2)}ms<br>`;
								resultDiv.innerHTML += `Performance improvement: ${((time1 - time2) / time1 * 100).toFixed(1)}% faster<br>`;
								
								// Verify same data
								if (uiProperties.length === uiProperties2.length) {
									resultDiv.innerHTML += `‚úÖ Data integrity: Both calls returned same number of properties<br>`;
								} else {
									resultDiv.innerHTML += `‚ö†Ô∏è Data mismatch: Different property counts (${uiProperties.length} vs ${uiProperties2.length})<br>`;
								}
								
								// Update UI with cached data
								currentProperties = uiProperties2;
								const groups = groupProperties(currentProperties);
								renderPropertyGroups(groups);
								updateElementSummary(elementGuid, elem[1], elem[2]);
								
								// Update cache stats
								getCacheStats();
								
							}).catch(function(error) {
								resultDiv.innerHTML += `‚ùå Error on second call: ${error}<br>`;
							});
						}).catch(function(error) {
							resultDiv.innerHTML += `‚ùå Error on first call: ${error}<br>`;
						});
					} else {
						resultDiv.innerHTML += '‚ùå ACAPI.GetCachedIFCProperties function not available.<br>';
						resultDiv.innerHTML += 'Make sure the plugin is rebuilt with cache functions.<br>';
					}
				});
			} else {
				resultDiv.innerHTML += '‚ùå ACAPI not available (testing outside Archicad?).<br>';
			}
		}
		
		function testCachedPropertiesWithRefresh() {
			const resultDiv = document.getElementById('performance-test-result');
			resultDiv.innerHTML = 'Testing cached properties with forced refresh...<br>';
			
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetSelectedElements === 'function') {
				ACAPI.GetSelectedElements().then(function(elemInfos) {
					if (!elemInfos || elemInfos.length === 0) {
						resultDiv.innerHTML += '‚ùå No element selected.<br>';
						return;
					}
					
					const elem = elemInfos[0];
					const elementGuid = elem[0];
					
					if (typeof ACAPI.GetCachedIFCPropertiesWithRefresh === 'function') {
						const startTime = performance.now();
						ACAPI.GetCachedIFCPropertiesWithRefresh(elementGuid).then(function(cppProperties) {
							const endTime = performance.now();
							const time = endTime - startTime;
							const uiProperties = transformCppPropertiesToUI(cppProperties);
							
							resultDiv.innerHTML += `Forced refresh: ${uiProperties.length} properties in ${time.toFixed(2)}ms<br>`;
							resultDiv.innerHTML += `‚úÖ Cache was cleared and fresh data loaded<br>`;
							
							// Update UI
							currentProperties = uiProperties;
							const groups = groupProperties(currentProperties);
							renderPropertyGroups(groups);
							updateElementSummary(elementGuid, elem[1], elem[2]);
							
							// Update cache stats
							getCacheStats();
							
						}).catch(function(error) {
							resultDiv.innerHTML += `‚ùå Error: ${error}<br>`;
						});
					} else {
						resultDiv.innerHTML += '‚ùå ACAPI.GetCachedIFCPropertiesWithRefresh not available.<br>';
					}
				});
			} else {
				resultDiv.innerHTML += '‚ùå ACAPI not available.<br>';
			}
		}
		
		function clearCache() {
			const resultDiv = document.getElementById('performance-test-result');
			resultDiv.innerHTML = 'Clearing cache...<br>';
			
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.ClearIFCPropertyCache === 'function') {
				ACAPI.ClearIFCPropertyCache().then(function(result) {
					resultDiv.innerHTML += `‚úÖ Cache cleared successfully<br>`;
					getCacheStats();
				}).catch(function(error) {
					resultDiv.innerHTML += `‚ùå Error clearing cache: ${error}<br>`;
				});
			} else {
				resultDiv.innerHTML += '‚ùå ACAPI.ClearIFCPropertyCache not available.<br>';
			}
		}
		
		function getCacheStats() {
			const statsDiv = document.getElementById('cache-stats-result');
			statsDiv.innerHTML = 'Loading cache statistics...<br>';
			
			if (typeof ACAPI !== 'undefined' && typeof ACAPI.GetIFCPropertyCacheSize === 'function') {
				// Get cache size
				ACAPI.GetIFCPropertyCacheSize().then(function(cacheSize) {
					statsDiv.innerHTML = `Cache size: ${cacheSize} elements<br>`;
					
					// In a real implementation, we might have more detailed stats
					// For now, just show the size
					if (cacheSize > 0) {
						statsDiv.innerHTML += `‚úÖ Cache is active with ${cacheSize} cached element(s)<br>`;
					} else {
						statsDiv.innerHTML += `‚ÑπÔ∏è Cache is empty<br>`;
					}
				}).catch(function(error) {
					statsDiv.innerHTML = `‚ùå Error getting cache stats: ${error}<br>`;
				});
			} else {
				statsDiv.innerHTML = '‚ùå Cache statistics not available.<br>';
			}
		}
		
		// Add test functions to the test suite
		window.testIFCProperties.testCompleteIFCProperties = testCompleteIFCProperties;
		window.testIFCProperties.comparePropertyCounts = comparePropertyCounts;
		window.testIFCProperties.testCachedProperties = testCachedProperties;
		window.testIFCProperties.testCachedPropertiesWithRefresh = testCachedPropertiesWithRefresh;
		window.testIFCProperties.clearCache = clearCache;
		window.testIFCProperties.getCacheStats = getCacheStats;
		
		// Update runAllTests to include new tests
		const originalRunAllTests = window.testIFCProperties.runAllTests;
		window.testIFCProperties.runAllTests = function() {
			console.log("=== Running IFC Property Reader Test Suite ===");
			this.validateData();
			this.testSingleElement();
			this.testMultipleElements();
			this.testEmptySelection();
			this.testSearch("test");
			this.testRealCppProperties();
			this.testErrorHandling();
			this.testIFCTypeRetrieval();
			this.testChineseTagSupport();
			this.testVersionDisplay();
			this.testLazyLoading();
			this.testCompleteIFCProperties();
			this.comparePropertyCounts();
			this.getCacheStats();
			this.testCachedProperties();
			console.log("=== All tests completed ===");
		};
	</script>
</body>
</html>